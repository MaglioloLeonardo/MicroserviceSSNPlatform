### File: anagrafica-service/pom.xml
----------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.5.3</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
    <groupId>tassproject</groupId>
    <artifactId>anagrafica-service</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>anagrafica-service</name>
    <description>anagrafica-service</description>
    <url/>
    <licenses>
        <license/>
    </licenses>
    <developers>
        <developer/>
    </developers>
    <scm>
        <connection/>
        <developerConnection/>
        <tag/>
        <url/>
    </scm>
    <properties>
        <java.version>17</java.version>
    </properties>
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

</project>


### File: anagrafica-service/src/main/java/tassproject/anagraficaservice/AnagraficaServiceApplication.java
----------------------------------------
package tassproject.anagraficaservice;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class AnagraficaServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(AnagraficaServiceApplication.class, args);
    }

}


### File: anagrafica-service/src/main/resources/application.properties
----------------------------------------
spring.application.name=anagrafica-service


### File: anagrafica-service/src/test/java/tassproject/anagraficaservice/AnagraficaServiceApplicationTests.java
----------------------------------------
package tassproject.anagraficaservice;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class AnagraficaServiceApplicationTests {

    @Test
    void contextLoads() {
    }

}


### File: api-gateway/pom.xml
----------------------------------------
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
                             https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>tassproject.backend</groupId>
        <artifactId>backend</artifactId>
        <version>0.0.1-SNAPSHOT</version>
        <relativePath>../pom.xml</relativePath>
    </parent>

    <artifactId>api-gateway</artifactId>
    <packaging>jar</packaging>
    <name>api-gateway</name>

    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-gateway</artifactId>
        </dependency>

        <!-- 🔐 sicurezza & JWT resource-server -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <!-- ★ protezione JWT -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
        </dependency>
        <!-- ★ JOSE support -->
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-oauth2-jose</artifactId>
        </dependency>
        <!-- ★ WebFlux per propagare header -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webflux</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>


### File: api-gateway/src/main/java/tassproject/apigateway/ApiGatewayApplication.java
----------------------------------------
package tassproject.apigateway;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration;

@SpringBootApplication(
        exclude = SecurityAutoConfiguration.class
)
public class ApiGatewayApplication {
    public static void main(String[] args) {
        SpringApplication.run(ApiGatewayApplication.class, args);
    }
}


### File: api-gateway/src/main/java/tassproject/apigateway/GlobalCorsConfig.java
----------------------------------------
package tassproject.apigateway;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.reactive.CorsWebFilter;
import org.springframework.web.cors.reactive.UrlBasedCorsConfigurationSource;

import java.util.List;

@Configuration
public class GlobalCorsConfig {

    @Bean
    public CorsWebFilter corsWebFilter() {
        CorsConfiguration cfg = new CorsConfiguration();
        cfg.setAllowedOrigins(List.of(
                "http://localhost:3000",
                "http://localhost:5173"
        ));
        cfg.setAllowedMethods(List.of("*"));
        cfg.setAllowedHeaders(List.of("*"));
        cfg.setAllowCredentials(true);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", cfg);

        return new CorsWebFilter(source);
    }
}


### File: api-gateway/src/main/java/tassproject/apigateway/JwtHeaderOrCookieAuthWebFilter.java
----------------------------------------
package tassproject.apigateway;

import org.springframework.http.HttpCookie;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.security.core.context.ReactiveSecurityContextHolder;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.security.oauth2.jwt.ReactiveJwtDecoder;
import org.springframework.security.oauth2.server.resource.authentication.ReactiveJwtAuthenticationConverterAdapter;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;
import org.springframework.web.server.WebFilter;
import org.springframework.web.server.WebFilterChain;
import reactor.core.publisher.Mono;

@Component
public class JwtHeaderOrCookieAuthWebFilter implements WebFilter {

    private final ReactiveJwtDecoder jwtDecoder;
    private final ReactiveJwtAuthenticationConverterAdapter converter;

    public JwtHeaderOrCookieAuthWebFilter(
            ReactiveJwtDecoder jwtDecoder,
            ReactiveJwtAuthenticationConverterAdapter converter
    ) {
        this.jwtDecoder = jwtDecoder;
        this.converter  = converter;
    }

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, WebFilterChain chain) {
        String authHeader = exchange.getRequest().getHeaders().getFirst(HttpHeaders.AUTHORIZATION);
        HttpCookie cookie = exchange.getRequest().getCookies().getFirst("access_token");
        String token = null;

        if (authHeader != null && authHeader.startsWith("Bearer ")) {
            token = authHeader.substring(7);
        } else if (cookie != null) {
            token = cookie.getValue();
        }
        if (token == null) {
            return chain.filter(exchange);
        }

        return jwtDecoder.decode(token)
                .flatMap(jwt -> converter.convert(jwt))
                .flatMap(auth ->
                        chain.filter(exchange)
                                .contextWrite(ReactiveSecurityContextHolder.withAuthentication(auth))
                )
                .onErrorResume(e -> unauthorized(exchange));
    }

    private Mono<Void> unauthorized(ServerWebExchange exchange) {
        exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);
        return exchange.getResponse().setComplete();
    }
}


### File: api-gateway/src/main/java/tassproject/apigateway/SecurityConfig.java
----------------------------------------
package tassproject.apigateway;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.config.Customizer;
import org.springframework.security.config.annotation.web.reactive.EnableWebFluxSecurity;
import org.springframework.security.config.web.server.ServerHttpSecurity;
import org.springframework.security.oauth2.jwt.NimbusReactiveJwtDecoder;
import org.springframework.security.oauth2.jwt.ReactiveJwtDecoder;
import org.springframework.security.oauth2.server.resource.authentication.*;
import org.springframework.security.web.server.SecurityWebFilterChain;

import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.StandardCharsets;
import java.util.Base64;

@Configuration
@EnableWebFluxSecurity
public class SecurityConfig {

    @Bean
    public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
        http
                .csrf(ServerHttpSecurity.CsrfSpec::disable)
                .authorizeExchange(ex -> ex
                        .pathMatchers(HttpMethod.OPTIONS, "/**").permitAll()
                        .pathMatchers("/oauth2/**","/login/**","/api/v1/auth/**","/actuator/**").permitAll()
                        .anyExchange().authenticated()
                )
                .oauth2ResourceServer(oauth2 -> oauth2
                        .jwt(jwt -> jwt.jwtAuthenticationConverter(grantConverter()))
                )
                .cors(Customizer.withDefaults());
        return http.build();
    }

    @Bean
    public ReactiveJwtAuthenticationConverterAdapter grantConverter() {
        JwtGrantedAuthoritiesConverter conv = new JwtGrantedAuthoritiesConverter();
        conv.setAuthorityPrefix("ROLE_");
        conv.setAuthoritiesClaimName("role");
        JwtAuthenticationConverter jwtConv = new JwtAuthenticationConverter();
        jwtConv.setJwtGrantedAuthoritiesConverter(conv);
        return new ReactiveJwtAuthenticationConverterAdapter(jwtConv);
    }

    @Bean
    public ReactiveJwtDecoder jwtDecoder(
            @Value("${jwt.secret:my_jwt_secret}") String secret
    ) {
        byte[] keyBytes;
        try {
            keyBytes = Base64.getDecoder().decode(secret);
        } catch (IllegalArgumentException ex) {
            keyBytes = secret.getBytes(StandardCharsets.UTF_8);
        }
        SecretKey key = new SecretKeySpec(keyBytes, "HmacSHA256");
        return NimbusReactiveJwtDecoder.withSecretKey(key).build();
    }
}


### File: api-gateway/src/main/resources/application.properties
----------------------------------------
spring.application.name=api-gateway
server.port=${SERVER_PORT:8080}

logging.level.org.springframework.security = DEBUG
logging.level.org.springframework.security.oauth2 = TRACE
logging.level.org.springframework.web = DEBUG
logging.level.tassproject.apigateway = DEBUG



logging.level.org.springframework.cloud.gateway = TRACE

logging.level.org.springframework.cloud.gateway.route = DEBUG
:
logging.level.tassproject.apigateway.filters = DEBUG


logging.level.reactor.netty = INFO   
logging.level.reactor.netty.http.client = DEBUG
logging.level.reactor.netty.http.server = DEBUG

#
logging.level.org.springframework.web.reactive = DEBUG
logging.level.org.springframework.web.server.adapter.HttpWebHandlerAdapter = TRACE


# RouteHandlerMapping, health, metrics ecc.
logging.level.org.springframework.boot.actuate.endpoint.web = DEBUG
logging.level.org.springframework.boot.actuate.gateway = DEBUG


# (NO JDBC: questo servizio non usa database direttamente)
# (NO JPA)
# (NO HikariCP)

# Health endpoint
management.endpoints.web.exposure.include=health,info

# === JWT segreto condiviso con auth-service ===
jwt.secret=${JWT_SECRET:my_jwt_secret}
jwt.expiration=${JWT_EXPIRATION_MS:3600000}


### File: api-gateway/src/main/resources/application.yml
----------------------------------------
server:
  port: ${SERVER_PORT:8080}

spring:
  application:
    name: api-gateway

  cloud:
    gateway:
      globalcors:
        corsConfigurations:
          "[/**]":
            allowedOrigins: "http://localhost:3000,http://localhost:5173"
            allowedMethods: "*"
            allowedHeaders: "*"
            allowCredentials: true

      routes:

        # ─────────────  OAUTH2 GOOGLE  ─────────────
        - id: oauth2-authorization
          uri: http://auth-service:8080
          predicates:
            - Path=/oauth2/authorization/google
          filters:
            - PreserveHostHeader

        - id: oauth2-callback
          uri: http://auth-service:8080
          predicates:
            - Path=/login/oauth2/**
          filters:
            - PreserveHostHeader

        # ─────────────  AUTH REST  ─────────────
        - id: auth-service
          uri: http://auth-service:8080
          predicates:
            - Path=/api/v1/auth/**

        # ─────────────  USER INFO / ROLES  ─────────────
        - id: user-service
          uri: http://auth-service:8080
          predicates:
            - Path=/api/v1/users/**

        # ─────────────  PRESCRIPTION  ─────────────
        - id: prescription-service
          uri: ${PRESCRIPTION_SERVICE_URL:http://prescription-service:8080}
          predicates:
            - Path=/api/v1/prescriptions/**
            - Path=/api/v1/patients/*/prescriptions/**
            - Path=/api/v1/doctors/**
            - Path=/api/v1/patients/*/drugs/**
            - Path=/api/v1/patients/*/doctors/**

        # ─────────────  DISPENSATION  ─────────────
        - id: dispensation-service
          uri: ${DISPENSATION_SERVICE_URL:http://dispensation-service:8080}
          predicates:
            - Path=/api/v1/dispensations/**
            - Path=/api/v1/prescriptions/*/dispensations/**
            - Path=/api/v1/pharmacists/**
            - Path=/api/v1/patients/*/pharmacists/**

        # ─────────────  INVENTORY  ─────────────
        - id: inventory-service
          uri: ${INVENTORY_SERVICE_URL:http://inventory-service:8080}
          predicates:
            - Path=/api/v1/inventory/**

        # ─────────────  NOTIFICATION  ─────────────
        - id: notification-service
          uri: ${NOTIFICATION_SERVICE_URL:http://notification-service:8080}
          predicates:
            - Path=/api/v1/notifications/**

      default-filters:
        - DedupeResponseHeader=Access-Control-Allow-Origin
        - PreserveHostHeader


### File: api-gateway/src/test/java/tassproject/apigateway/ApiGatewayApplicationTests.java
----------------------------------------
package tassproject.apigateway;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest(
        classes = ApiGatewayApplication.class,
        properties = {
                "spring.cloud.compatibility-verifier.enabled=false"
        }
)
class ApiGatewayApplicationTests {

    @Test
    void contextLoads() {
    }
}


### File: auth-service/pom.xml
----------------------------------------
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
                             https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>tassproject.backend</groupId>
        <artifactId>backend</artifactId>
        <version>0.0.1-SNAPSHOT</version>
        <relativePath>../pom.xml</relativePath>
    </parent>

    <artifactId>auth-service</artifactId>
    <name>auth-service</name>
    <packaging>jar</packaging>

    <properties>
        <java.version>17</java.version>
        <jjwt.version>0.12.5</jjwt.version>
    </properties>

    <dependencies>
        <!-- Core -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-oauth2-client</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
        </dependency>
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>

        <!-- JWT -->
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-api</artifactId>
            <version>${jjwt.version}</version>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-impl</artifactId>
            <version>${jjwt.version}</version>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-jackson</artifactId>
            <version>${jjwt.version}</version>
            <scope>runtime</scope>
        </dependency>

        <!-- Annotation API per javax.annotation.PostConstruct -->
        <dependency>
            <groupId>javax.annotation</groupId>
            <artifactId>javax.annotation-api</artifactId>
            <version>1.3.2</version>
        </dependency>

        <!-- Validation & Lombok -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <scope>provided</scope>
        </dependency>

        <!-- Test -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>

    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>


### File: auth-service/src/main/java/tassproject/authservice/AuthController.java
----------------------------------------
package tassproject.authservice.controller;

import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;
import tassproject.authservice.*;

import java.io.IOException;

@RestController
@RequestMapping("/api/v1/auth")
@RequiredArgsConstructor
public class AuthController {

    private final AuthService auth;

    /* ---------------- REGISTER ---------------- */
    @PostMapping("/register")
    @ResponseStatus(HttpStatus.CREATED)
    public AuthResponse register(@Valid @RequestBody RegisterRequest body) {
        return auth.register(body);
    }

        /* ---------------- LOGIN ------------------- */
                @PostMapping("/login")
    public AuthResponse login(
            @Valid @RequestBody LoginRequest body,
            HttpServletResponse response
    ) {
                // 1) Effettuo l’autenticazione e genero il JWT
                        AuthResponse authResp = auth.login(body);

                        // 2) Imposto il cookie HttpOnly con il token
                                Cookie jwtCookie = new Cookie("access_token", authResp.accessToken());
                jwtCookie.setHttpOnly(true);
                jwtCookie.setSecure(true);    // in produzione lascia true
                jwtCookie.setPath("/");
                jwtCookie.setMaxAge(3600);    // durata in secondi (come jwt.expiration)
                response.addCookie(jwtCookie);

                        // 3) Ritorno l’intero AuthResponse (tokenType + accessToken) come JSON
                                return authResp;
            }

    /* ---------------- LOGIN AUTOMATICO -------- */
    @GetMapping("/me")
    public User me(Authentication authentication) {
        if (authentication == null)
            throw new IllegalStateException("Non autenticato");
        return auth.me(authentication.getName());
    }

    /* ---------------- LOGOUT COMPLETO --------- */
    @PostMapping("/logout")
    @ResponseStatus(HttpStatus.NO_CONTENT)
    public void logout(Authentication authentication,
                       HttpServletResponse response) {

        if (authentication != null) {
            auth.logout(authentication.getName());
        }
        /* cancella eventuale cookie JWT (se lo usi) */
        Cookie cookie = new Cookie("access_token", null);
        cookie.setHttpOnly(true);
        cookie.setPath("/");
        cookie.setMaxAge(0);
        response.addCookie(cookie);
    }
}


### File: auth-service/src/main/java/tassproject/authservice/AuthResponse.java
----------------------------------------
package tassproject.authservice;

public record AuthResponse(String tokenType, String accessToken) {
    public static AuthResponse bearer(String jwt) {
        return new AuthResponse("Bearer", jwt);
    }
}


### File: auth-service/src/main/java/tassproject/authservice/AuthService.java
----------------------------------------
package tassproject.authservice;

import lombok.RequiredArgsConstructor;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import tassproject.authservice.Citizen;
import tassproject.authservice.CitizenRepository;
import tassproject.authservice.RoleRepository;
import tassproject.authservice.repository.UserProfileRepository;
import tassproject.authservice.UserRepository;

import java.util.Date;
import java.util.Optional;
import java.util.Set;
import java.util.UUID;

@Service
@RequiredArgsConstructor
public class AuthService {

    private final UserRepository         users;
    private final RoleRepository         roles;
    private final CitizenRepository      citizens;
    private final UserProfileRepository  profiles;
    private final PasswordEncoder        passwordEncoder;
    private final JwtUtil                jwtUtil;

    /* ------------------ REGISTER ------------------ */
    @Transactional
    public AuthResponse register(RegisterRequest req) {
        String username = req.email().toLowerCase();
        if (users.findByUsername(username).isPresent()) {
            throw new IllegalArgumentException("Username già in uso");
        }
        if (citizens.existsByCf(req.cf())) {
            throw new IllegalArgumentException("CF già presente");
        }

        // 1) Salva cittadino
        UUID cid = UUID.randomUUID();
        String tipoUtente = switch (req.role()) {
            case PATIENT    -> "PAZIENTE";
            case DOCTOR     -> "MEDICO";
            case PHARMACIST -> "FARMACISTA";
            case ADMIN      -> "ADMIN";
        };
        Citizen citizen = new Citizen(
                cid,
                req.cf(),
                req.nome(),
                req.cognome(),
                req.dataNascita(),
                req.luogoNascita(),
                req.cittaResidenza(),
                tipoUtente
        );
        citizens.save(citizen);

        // 2) Salva user & ruolo
        RoleEntity roleEnt = roles.findByName(req.role().name())
                .orElseThrow(() -> new IllegalStateException("Ruolo non trovato"));
        User user = new User(
                username,
                passwordEncoder.encode(req.password()),
                Set.of(roleEnt)
        );
        users.save(user);

        // 3) Mappa user ↔ citizen
        profiles.save(new UserProfile(user.getId(), cid));

        // 4) JWT completo di citizen_id
        return AuthResponse.bearer(jwtUtil.generateToken(user, cid));
    }

    /* ------------------- LOGIN -------------------- */
    public AuthResponse login(LoginRequest req) {
        User user = users.findByUsername(req.email().toLowerCase())
                .orElseThrow(() -> new IllegalArgumentException("Credenziali non valide"));

        if (!passwordEncoder.matches(req.password(), user.getPassword())) {
            throw new IllegalArgumentException("Credenziali non valide");
        }

        // Recupera il citizenId dal mapping (usando findById)
        UUID citizenId = profiles.findById(user.getId())
                .map(UserProfile::getCitizenId)
                .orElseThrow(() -> new IllegalStateException("Profilo utente mancante"));

        return AuthResponse.bearer(jwtUtil.generateToken(user, citizenId));
    }

    /* ------------------- LOGOUT ------------------- */
    @Transactional
    public void logout(String username) {
        users.findByUsername(username.toLowerCase()).ifPresent(u -> {
            u.setSessionVersion(u.getSessionVersion() + 1);
            users.save(u);
        });
    }

    /* --------------------- ME --------------------- */
    public User me(String username) {
        return users.findByUsername(username.toLowerCase())
                .orElseThrow(() -> new IllegalStateException("Utente non trovato"));
    }
}


### File: auth-service/src/main/java/tassproject/authservice/AuthServiceApplication.java
----------------------------------------
package tassproject.authservice;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class AuthServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(AuthServiceApplication.class, args);
    }
}


### File: auth-service/src/main/java/tassproject/authservice/Citizen.java
----------------------------------------
package tassproject.authservice;

import jakarta.persistence.*;
import java.time.LocalDate;
import java.util.UUID;

@Entity
@Table(name = "citizens", schema = "anagrafica_service")
public class Citizen {

    @Id
    @Column(columnDefinition = "uuid")
    private UUID id;

    @Column(nullable = false, unique = true, length = 16)
    private String cf;

    @Column(nullable = false, length = 100)
    private String nome;

    @Column(nullable = false, length = 100)
    private String cognome;

    @Column(name = "data_nascita", nullable = false)
    private LocalDate dataNascita;

    @Column(name = "luogo_nascita", length = 100)
    private String luogoNascita;

    @Column(name = "citta_residenza", length = 100)
    private String cittaResidenza;

    @Column(name = "tipo_utente", nullable = false, length = 16)
    private String tipoUtente;

    protected Citizen() {}

    public Citizen(UUID id,
                   String cf,
                   String nome,
                   String cognome,
                   LocalDate dataNascita,
                   String luogoNascita,
                   String cittaResidenza,
                   String tipoUtente) {
        this.id             = id;
        this.cf             = cf;
        this.nome           = nome;
        this.cognome        = cognome;
        this.dataNascita    = dataNascita;
        this.luogoNascita   = luogoNascita;
        this.cittaResidenza = cittaResidenza;
        this.tipoUtente     = tipoUtente;
    }

    /* -------- getters & setters ------- */
    public UUID getId() { return id; }
    public void setId(UUID id) { this.id = id; }

    public String getCf() { return cf; }
    public void setCf(String cf) { this.cf = cf; }

    public String getNome() { return nome; }
    public void setNome(String nome) { this.nome = nome; }

    public String getCognome() { return cognome; }
    public void setCognome(String cognome) { this.cognome = cognome; }

    public LocalDate getDataNascita() { return dataNascita; }
    public void setDataNascita(LocalDate dataNascita) { this.dataNascita = dataNascita; }

    public String getLuogoNascita() { return luogoNascita; }
    public void setLuogoNascita(String luogoNascita) { this.luogoNascita = luogoNascita; }

    public String getCittaResidenza() { return cittaResidenza; }
    public void setCittaResidenza(String cittaResidenza) { this.cittaResidenza = cittaResidenza; }

    public String getTipoUtente() { return tipoUtente; }
    public void setTipoUtente(String tipoUtente) { this.tipoUtente = tipoUtente; }
}

### File: auth-service/src/main/java/tassproject/authservice/CitizenRepository.java
----------------------------------------
package tassproject.authservice;

import org.springframework.data.jpa.repository.JpaRepository;
import tassproject.authservice.Citizen;

import java.util.UUID;

public interface CitizenRepository extends JpaRepository<Citizen, UUID> {
    boolean existsByCf(String cf);
}

### File: auth-service/src/main/java/tassproject/authservice/GlobalCorsConfig.java
----------------------------------------
package tassproject.authservice;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.filter.CorsFilter;

import java.util.List;

@Configuration
public class GlobalCorsConfig {

    @Bean
    public CorsFilter corsFilter() {
        CorsConfiguration cfg = new CorsConfiguration();
        cfg.setAllowedOrigins(List.of(
                "http://localhost:5173",
                "http://localhost:3000"
        ));
        cfg.setAllowedMethods(List.of("*"));
        cfg.setAllowedHeaders(List.of("*"));
        cfg.setAllowCredentials(true);

        var source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", cfg);

        return new CorsFilter(source);
    }
}


### File: auth-service/src/main/java/tassproject/authservice/GlobalExceptionHandler.java
----------------------------------------
package tassproject.authservice;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.http.HttpStatus;

import java.util.stream.Collectors;

@ControllerAdvice
public class GlobalExceptionHandler {

    public record ErrorResponse(String error, String message) {}

    // Validazione @Valid fallita → 400 Bad Request
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleValidation(MethodArgumentNotValidException ex) {
        String details = ex.getBindingResult().getFieldErrors().stream()
                .map(fe -> fe.getField() + ": " + fe.getDefaultMessage())
                .collect(Collectors.joining("; "));
        return ResponseEntity
                .status(HttpStatus.BAD_REQUEST)
                .body(new ErrorResponse("Validation Failed", details));
    }

    // IllegalArgumentException dal business logic → 400 Bad Request
    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<ErrorResponse> handleBadRequest(IllegalArgumentException ex) {
        return ResponseEntity
                .status(HttpStatus.BAD_REQUEST)
                .body(new ErrorResponse("Bad Request", ex.getMessage()));
    }

    // Fallback per qualsiasi altra eccezione → 500 Internal Server Error
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleAll(Exception ex) {
        return ResponseEntity
                .status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(new ErrorResponse("Internal Server Error", ex.getMessage()));
    }
}


### File: auth-service/src/main/java/tassproject/authservice/JwtUtil.java
----------------------------------------
package tassproject.authservice;

import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.io.Decoders;
import io.jsonwebtoken.io.DecodingException;
import io.jsonwebtoken.security.Keys;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import javax.annotation.PostConstruct;
import javax.crypto.SecretKey;
import java.nio.charset.StandardCharsets;
import java.util.Date;
import java.util.List;
import java.util.UUID;

@Component
public class JwtUtil {

    @Value("${jwt.secret}")
    private String secretValue;

    @Value("${jwt.expiration}")
    private long jwtExpirationMs;

    private SecretKey key;

    @PostConstruct
    public void init() {
        byte[] keyBytes;
        try {
            keyBytes = Decoders.BASE64.decode(secretValue);
        } catch (IllegalArgumentException | DecodingException ex) {
            keyBytes = secretValue.getBytes(StandardCharsets.UTF_8);
        }
        if (keyBytes.length < 32) {
            throw new IllegalStateException(
                    "Il JWT_SECRET configurato è troppo corto (" +
                            (keyBytes.length * 8) + " bit). Deve essere almeno 256 bit.");
        }
        this.key = Keys.hmacShaKeyFor(keyBytes);
    }

    /**
     * Nuovo overload che include il claim "citizen_id".
     */
    public String generateToken(User user, UUID citizenId) {
        var builder = Jwts.builder()
                .setSubject(user.getUsername())
                .claim("ver", user.getSessionVersion())
                .claim("role", user.getRoles().stream()
                        .map(RoleEntity::getName)
                        .toList())
                .setIssuedAt(new Date())
                .setExpiration(new Date(System.currentTimeMillis() + jwtExpirationMs));

        if (citizenId != null) {
            builder.claim("citizen_id", citizenId.toString());
        }
        return builder.signWith(key, SignatureAlgorithm.HS256).compact();
    }

    /**
     * Metodo legacy (es. OAuth2 login) ‒ genera comunque un token ma **senza** citizen_id.
     */
    public String generateToken(User user) {
        return generateToken(user, null);
    }

    public String getUsernameFromToken(String token) {
        return Jwts.parser()
                .verifyWith(key)
                .build()
                .parseSignedClaims(token)
                .getPayload()
                .getSubject();
    }


}


### File: auth-service/src/main/java/tassproject/authservice/LoginRequest.java
----------------------------------------
package tassproject.authservice;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;

public record LoginRequest(
        @NotBlank @Email String email,
        @NotBlank String password) {}


### File: auth-service/src/main/java/tassproject/authservice/OAuth2LoginSuccessHandler.java
----------------------------------------
package tassproject.authservice;

import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.RequiredArgsConstructor;
import org.springframework.security.core.Authentication;
import org.springframework.security.oauth2.core.user.OAuth2User;
import org.springframework.security.web.authentication.AuthenticationSuccessHandler;
import org.springframework.stereotype.Component;
import tassproject.authservice.RoleRepository;
import tassproject.authservice.UserRepository;

import jakarta.servlet.ServletException;
import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.Map;
import java.util.Set;

@Component
@RequiredArgsConstructor
public class OAuth2LoginSuccessHandler implements AuthenticationSuccessHandler {

    private final UserRepository userRepository;
    private final RoleRepository roleRepository;
    private final JwtUtil jwtUtil;

    @Override
    public void onAuthenticationSuccess(HttpServletRequest request,
                                        HttpServletResponse response,
                                        Authentication authentication)
            throws IOException, ServletException {

        /* -------- 1) estrai e‑mail -------- */
        OAuth2User oAuth2User = (OAuth2User) authentication.getPrincipal();
        String email = oAuth2User.getAttribute("email");

        if (email == null) {
            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
            response.setContentType("application/json");
            new ObjectMapper().writeValue(response.getWriter(),
                    Map.of("error", "Unauthorized", "message", "No email provided by Google"));
            return;
        }

        /* -------- 2) trova ruolo PATIENT -------- */
        RoleEntity patientRole = roleRepository.findByName("PATIENT")
                .orElseThrow(() -> new IllegalStateException("Ruolo PATIENT mancante a DB"));

        /* -------- 3) upsert utente -------- */
        User user = userRepository.findByUsername(email.toLowerCase())
                .orElseGet(() -> userRepository.save(
                        new User(email.toLowerCase(), "", Set.of(patientRole))
                ));

        /* -------- 4) JWT + cookie -------- */
        String jwt = jwtUtil.generateToken(user);
        Cookie cookie = new Cookie("access_token", jwt);
        cookie.setHttpOnly(true);
        cookie.setSecure(request.isSecure());
        cookie.setPath("/");
        cookie.setMaxAge(60 * 60);
        response.addCookie(cookie);

        /* -------- 5) redirect -------- */
        response.sendRedirect("http://localhost:3000/seleziona-ruolo");
    }
}


### File: auth-service/src/main/java/tassproject/authservice/OAuth2SecurityConfig.java
----------------------------------------
package tassproject.authservice;

import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.annotation.Order;
import org.springframework.http.HttpMethod;                    // ★
import org.springframework.security.config.Customizer;      // ★
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
@RequiredArgsConstructor
public class OAuth2SecurityConfig {

    private final OAuth2LoginSuccessHandler successHandler;
    private final RestAuthenticationEntryPoint restEntryPoint;
    private final RestAccessDeniedHandler restAccessDeniedHandler;

    /*@Bean
    @Order(1)
    public SecurityFilterChain oauth2LoginFilterChain(HttpSecurity http) throws Exception {
        http
                .securityMatcher(
                        "/oauth2/authorization/google",
                        "/login/oauth2/**",
                        "/api/v1/auth/**",
                        "/actuator/**"
                )
                .csrf(csrf -> csrf.disable())
                            .authorizeHttpRequests(auth -> auth
                                    // ★ sempre OK il preflight
                                    .requestMatchers(HttpMethod.OPTIONS, "/**").permitAll()
                                    .anyRequest().permitAll()
                            )
                .exceptionHandling(ex -> ex
                        .authenticationEntryPoint(restEntryPoint)
                        .accessDeniedHandler(restAccessDeniedHandler)
                )
                .sessionManagement(sm -> sm.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .oauth2Login(oauth2 -> oauth2.successHandler(successHandler))
                .cors(Customizer.withDefaults());
        return http.build();
    }*/
}


### File: auth-service/src/main/java/tassproject/authservice/RegisterRequest.java
----------------------------------------
package tassproject.authservice;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Past;
import java.time.LocalDate;

public record RegisterRequest(
        /* Credenziali */
        @NotBlank @Email String email,
        @NotBlank           String password,
        @NotNull            Role   role,
        /* Campi anagrafica */
        @NotBlank String  cf,
        @NotBlank String  nome,
        @NotBlank String  cognome,
        @Past     LocalDate dataNascita,
        @NotBlank String  luogoNascita,
        @NotBlank String  cittaResidenza
) {}

### File: auth-service/src/main/java/tassproject/authservice/ResourceServerConfig.java
----------------------------------------
package tassproject.authservice;

import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.annotation.Order;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
@EnableWebSecurity
@RequiredArgsConstructor
public class ResourceServerConfig {

    private final JwtDecoder jwtDecoder;
    /*
    @Bean
    @Order(2)
    public SecurityFilterChain resourceServerFilterChain(HttpSecurity http) throws Exception {
        http
                .csrf(csrf -> csrf.disable())
                .authorizeHttpRequests(auth -> auth
                        .anyRequest().authenticated()
                )
                .sessionManagement(sm -> sm.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .oauth2ResourceServer(oauth2 -> oauth2
                        .jwt(jwt -> jwt.decoder(jwtDecoder))
                );
        return http.build();
    }*/
}


### File: auth-service/src/main/java/tassproject/authservice/RestAccessDeniedHandler.java
----------------------------------------
package tassproject.authservice;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.http.MediaType;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.web.access.AccessDeniedHandler;
import org.springframework.stereotype.Component;

import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import java.io.IOException;

@Component
public class RestAccessDeniedHandler implements AccessDeniedHandler {

    private final ObjectMapper mapper = new ObjectMapper();

    @Override
    public void handle(
            HttpServletRequest request,
            HttpServletResponse response,
            AccessDeniedException accessDeniedException
    ) throws IOException {
        response.setStatus(HttpServletResponse.SC_FORBIDDEN);
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        var error = new GlobalExceptionHandler.ErrorResponse(
                "Forbidden",
                accessDeniedException.getMessage()
        );
        mapper.writeValue(response.getOutputStream(), error);
    }
}


### File: auth-service/src/main/java/tassproject/authservice/RestAuthenticationEntryPoint.java
----------------------------------------
package tassproject.authservice;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.http.MediaType;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.stereotype.Component;

import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import java.io.IOException;

@Component
public class RestAuthenticationEntryPoint implements AuthenticationEntryPoint {

    private final ObjectMapper mapper = new ObjectMapper();

    @Override
    public void commence(
            HttpServletRequest request,
            HttpServletResponse response,
            AuthenticationException authException
    ) throws IOException {
        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        // usa lo stesso DTO ErrorResponse del GlobalExceptionHandler
        var error = new GlobalExceptionHandler.ErrorResponse(
                "Unauthorized",
                authException.getMessage()
        );
        mapper.writeValue(response.getOutputStream(), error);
    }
}


### File: auth-service/src/main/java/tassproject/authservice/Role.java
----------------------------------------
package tassproject.authservice;

public enum Role {
    PATIENT,
    DOCTOR,
    PHARMACIST,
    ADMIN
}


### File: auth-service/src/main/java/tassproject/authservice/RoleEntity.java
----------------------------------------
package tassproject.authservice;

import jakarta.persistence.*;

@Entity
@Table(name = "roles", schema = "auth_service")
public class RoleEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;

    @Column(nullable = false, unique = true)
    private String name;

    protected RoleEntity() { }

    public RoleEntity(String name) {
        this.name = name;
    }

    /* ---------- getters & setters ---------- */
    public Integer getId()            { return id; }
    public void    setId(Integer id)  { this.id = id; }

    public String  getName()          { return name; }
    public void    setName(String n)  { this.name = n; }
}


### File: auth-service/src/main/java/tassproject/authservice/RoleRepository.java
----------------------------------------
package tassproject.authservice;

import org.springframework.data.jpa.repository.JpaRepository;
import tassproject.authservice.RoleEntity;

import java.util.Optional;

public interface RoleRepository extends JpaRepository<RoleEntity, Integer> {
    Optional<RoleEntity> findByName(String name);
}


### File: auth-service/src/main/java/tassproject/authservice/SecurityConfig.java
----------------------------------------
package tassproject.authservice;

import com.nimbusds.jose.jwk.source.ImmutableSecret;
import io.jsonwebtoken.io.Decoders;
import io.jsonwebtoken.security.Keys;
import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.ProviderManager;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.Customizer;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.oauth2.core.DelegatingOAuth2TokenValidator;
import org.springframework.security.oauth2.core.OAuth2TokenValidator;
import org.springframework.security.oauth2.jwt.*;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;
import tassproject.authservice.UserRepository;

import javax.crypto.SecretKey;

@Configuration
@EnableWebSecurity
@RequiredArgsConstructor
public class SecurityConfig implements WebMvcConfigurer {

    private final UserRepository users;
    private final RestAuthenticationEntryPoint restEntryPoint;
    private final RestAccessDeniedHandler      restAccessDeniedHandler;
    private final OAuth2LoginSuccessHandler    oAuth2LoginSuccessHandler;

    /* -------- UserDetailsService: ruoli dal join‑table -------- */
    @Bean
    public UserDetailsService userDetailsService() {
        return username -> users
                .findByUsername(username.toLowerCase())
                .map(u -> org.springframework.security.core.userdetails.User
                        .withUsername(u.getUsername())
                        .password(u.getPassword())
                        .roles(u.getRoles().stream()
                                .map(RoleEntity::getName)
                                .toArray(String[]::new))
                        .build())
                .orElseThrow(() ->
                        new UsernameNotFoundException("Utente non trovato: " + username));
    }


    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationManager authenticationManager(UserDetailsService uds) {
        DaoAuthenticationProvider provider = new DaoAuthenticationProvider();
        provider.setUserDetailsService(uds);
        provider.setPasswordEncoder(passwordEncoder());
        return new ProviderManager(provider);
    }

    /* ---------- JWT (HMAC‑SHA256) ---------- */
    @Bean
    public JwtEncoder jwtEncoder(@Value("${jwt.secret}") String secret) {
        byte[] keyBytes = Decoders.BASE64.decode(secret);
        SecretKey key   = Keys.hmacShaKeyFor(keyBytes);
        return new NimbusJwtEncoder(new ImmutableSecret<>(key));
    }

    @Bean
    public JwtDecoder jwtDecoder(@Value("${jwt.secret}") String secret) {
        byte[] keyBytes = Decoders.BASE64.decode(secret);
        SecretKey key   = Keys.hmacShaKeyFor(keyBytes);

        NimbusJwtDecoder decoder = NimbusJwtDecoder.withSecretKey(key).build();
        OAuth2TokenValidator<Jwt> defVal  = JwtValidators.createDefault();
        OAuth2TokenValidator<Jwt> verVal  = new SessionVersionValidator(users);
        decoder.setJwtValidator(new DelegatingOAuth2TokenValidator<>(defVal, verVal));

        return decoder;
    }

    /* ---------- CORS dev SPA ---------- */
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")
                .allowedOrigins("http://localhost:3000")
                .allowedMethods("GET","POST","PUT","DELETE","OPTIONS")
                .allowedHeaders("Authorization","Content-Type")
                .allowCredentials(true);
    }

    /* ---------- Security filter‑chain ---------- */
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http,
                                           JwtDecoder jwtDecoder) throws Exception {
        http
                .csrf(csrf -> csrf.disable())
                .cors(Customizer.withDefaults())
                .sessionManagement(sm -> sm.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .authorizeHttpRequests(req -> req
                        .requestMatchers(HttpMethod.OPTIONS,"/**").permitAll()
                        .requestMatchers("/api/v1/auth/login",
                                "/api/v1/auth/register",
                                "/oauth2/**").permitAll()
                        .anyRequest().authenticated()
                )
                .oauth2ResourceServer(oauth2 -> oauth2.jwt(jwt -> jwt.decoder(jwtDecoder)))
                .exceptionHandling(ex -> ex
                        .authenticationEntryPoint(restEntryPoint)
                        .accessDeniedHandler(restAccessDeniedHandler))
                .oauth2Login(oauth2 -> oauth2.successHandler(oAuth2LoginSuccessHandler));

        return http.build();
    }
}


### File: auth-service/src/main/java/tassproject/authservice/SessionVersionValidator.java
----------------------------------------
package tassproject.authservice;

import org.springframework.security.oauth2.core.OAuth2Error;
import org.springframework.security.oauth2.core.OAuth2TokenValidator;
import org.springframework.security.oauth2.core.OAuth2TokenValidatorResult;
import org.springframework.security.oauth2.jwt.Jwt;
import tassproject.authservice.UserRepository;

/**
 * Rifiuta i JWT la cui 'ver' non coincide con la sessionVersion salvata a DB.
 */
public class SessionVersionValidator implements OAuth2TokenValidator<Jwt> {

    private final UserRepository users;

    public SessionVersionValidator(UserRepository users) {
        this.users = users;
    }

    @Override
    public OAuth2TokenValidatorResult validate(Jwt token) {
        // Prendi il claim "ver" come Number (gestisce Long, Integer, ecc.)
        Number rawVer = token.getClaim("ver");
        String username = token.getSubject();

        if (rawVer == null || username == null) {
            return OAuth2TokenValidatorResult.failure(
                    new OAuth2Error("invalid_token", "Missing 'ver' claim or subject", null));
        }

        // Converte in int (o long se preferisci) e confronta con il DB
        int ver = rawVer.intValue();

        boolean valid = users.findByUsername(username.toLowerCase())
                .map(u -> ver == u.getSessionVersion())  // qui u.getSessionVersion() è un Integer
                .orElse(false);

        return valid
                ? OAuth2TokenValidatorResult.success()
                : OAuth2TokenValidatorResult.failure(
                new OAuth2Error("invalid_token", "Session revoked", null));
    }
}


### File: auth-service/src/main/java/tassproject/authservice/User.java
----------------------------------------
package tassproject.authservice;

import jakarta.persistence.*;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "users", schema = "auth_service")
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true)
    private String username;

    @Column(nullable = false)
    private String password;

    @Column(name = "session_version", nullable = false)
    private Integer sessionVersion = 0;

    /* ----------  NUOVO: ruoli M‑N  ---------- */
    @ManyToMany(fetch = FetchType.EAGER)
    @JoinTable(
            name = "user_roles",
            schema = "auth_service",
            joinColumns = @JoinColumn(name = "user_id"),
            inverseJoinColumns = @JoinColumn(name = "role_id"))
    private Set<RoleEntity> roles = new HashSet<>();
    /* ---------------------------------------- */

    protected User() { }

    public User(String username, String password, Set<RoleEntity> roles) {
        this.username = username;
        this.password = password;
        this.roles    = roles;
    }

    /* ---------- getters & setters ---------- */
    public Long              getId()              { return id; }
    public void              setId(Long id)       { this.id = id; }

    public String            getUsername()        { return username; }
    public void              setUsername(String u){ this.username = u; }

    public String            getPassword()        { return password; }
    public void              setPassword(String p){ this.password = p; }

    public Integer           getSessionVersion()  { return sessionVersion; }
    public void              setSessionVersion(Integer v){ this.sessionVersion = v; }

    public Set<RoleEntity>   getRoles()           { return roles; }
    public void              setRoles(Set<RoleEntity> r){ this.roles = r; }
}


### File: auth-service/src/main/java/tassproject/authservice/UserProfile.java
----------------------------------------
package tassproject.authservice;

import jakarta.persistence.*;
import java.util.UUID;

@Entity
@Table(name = "user_profiles", schema = "auth_service")
public class UserProfile {

    @Id
    @Column(name = "user_id")
    private Long userId;

    @Column(name = "citizen_id", nullable = false, columnDefinition = "uuid", unique = true)
    private UUID citizenId;

    protected UserProfile() {}

    public UserProfile(Long userId, UUID citizenId) {
        this.userId    = userId;
        this.citizenId = citizenId;
    }

    /* getters */
    public Long getUserId()   { return userId;   }
    public UUID getCitizenId(){ return citizenId;}
}

### File: auth-service/src/main/java/tassproject/authservice/UserProfileRepository.java
----------------------------------------
package tassproject.authservice.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import tassproject.authservice.UserProfile;

public interface UserProfileRepository extends JpaRepository<UserProfile, Long> {
}

### File: auth-service/src/main/java/tassproject/authservice/UserQueryController.java
----------------------------------------
package tassproject.authservice;

import lombok.RequiredArgsConstructor;
import org.springframework.web.bind.annotation.*;
import tassproject.authservice.UserRepository;

import java.util.List;

@RestController
@RequestMapping("/api/v1/users")
@RequiredArgsConstructor
public class UserQueryController {

    private final UserRepository users;

    /* ---- ruoli associati all’utente ---- */
    @GetMapping("/{username}/roles")
    public List<String> roles(@PathVariable String username) {
        return users.findByUsername(username.toLowerCase())
                .map(u -> u.getRoles().stream()
                        .map(RoleEntity::getName)
                        .toList())
                .orElse(List.of());
    }
}


### File: auth-service/src/main/java/tassproject/authservice/UserRepository.java
----------------------------------------
package tassproject.authservice;

import org.springframework.data.jpa.repository.JpaRepository;
import tassproject.authservice.User;

import java.util.Optional;

public interface UserRepository extends JpaRepository<User, Long> {

    /* Cerca l’utente per username (e-mail normalizzata) */
    Optional<User> findByUsername(String username);
}


### File: auth-service/src/main/resources/application.properties
----------------------------------------
# ????????? Logging Spring Security ?????????

logging.level.org.springframework.security = DEBUG
logging.level.org.springframework.security.oauth2 = TRACE
logging.level.org.springframework.web = DEBUG
logging.level.tassproject.apigateway = DEBUG



logging.level.org.springframework.cloud.gateway = TRACE

logging.level.org.springframework.cloud.gateway.route = DEBUG

logging.level.tassproject.apigateway.filters = DEBUG


logging.level.reactor.netty = INFO  
logging.level.reactor.netty.http.client = DEBUG
logging.level.reactor.netty.http.server = DEBUG


logging.level.org.springframework.web.reactive = DEBUG
logging.level.org.springframework.web.server.adapter.HttpWebHandlerAdapter = TRACE


# RouteHandlerMapping, health, metrics ecc.
logging.level.org.springframework.boot.actuate.endpoint.web = DEBUG
logging.level.org.springframework.boot.actuate.gateway = DEBUG


# ????????? Spring Boot ?????????
spring.application.name=auth-service
server.port=${SERVER_PORT:8080}

# ????????? Datasource ?????????
spring.datasource.url=${SPRING_DATASOURCE_URL:jdbc:postgresql://localhost:5432/mydatabase}
spring.datasource.username=${SPRING_DATASOURCE_USERNAME:myuser}
spring.datasource.password=${SPRING_DATASOURCE_PASSWORD:secret}
spring.datasource.driver-class-name=org.postgresql.Driver

# ????????? JPA / Hibernate ?????????
spring.jpa.hibernate.ddl-auto=${SPRING_JPA_HIBERNATE_DDL_AUTO:update}
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.properties.hibernate.default_schema=auth_service

# ????????? JWT Settings ?????????
jwt.secret=${JWT_SECRET:my_jwt_secret}
jwt.expiration=${JWT_EXPIRATION_MS:3600000}

# ????????? OAuth2 Google Registration ?????????
spring.security.oauth2.client.registration.google.client-id=1052773766792-14leidinpkl862i67o4k62ck8iqtqjrn.apps.googleusercontent.com
spring.security.oauth2.client.registration.google.client-secret=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
spring.security.oauth2.client.registration.google.redirect-uri={baseUrl}/login/oauth2/code/{registrationId}
spring.security.oauth2.client.registration.google.scope=openid,profile,email

# ????????? OAuth2 Google Provider Endpoints ?????????
spring.security.oauth2.client.provider.google.authorization-uri=https://accounts.google.com/o/oauth2/auth
spring.security.oauth2.client.provider.google.token-uri=https://oauth2.googleapis.com/token
spring.security.oauth2.client.provider.google.user-info-uri=https://www.googleapis.com/oauth2/v3/userinfo
spring.security.oauth2.client.provider.google.user-name-attribute=sub

# ????????? Forward Headers & Actuator ?????????
server.forward-headers-strategy=native
management.endpoints.web.exposure.include=health,info


### File: auth-service/src/main/resources/application.yml
----------------------------------------
spring:
  cloud:
    gateway:
      globalcors:
        corsConfigurations:
          "[/**]":
            allowedOrigins: "http://localhost:5173,http://localhost:3000"
            allowedMethods: "*"
            allowedHeaders: "*"


### File: auth-service/src/test/java/tassproject/authservice/AuthServiceApplicationTests.java
----------------------------------------
package tassproject.authservice;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class AuthServiceApplicationTests {

    @Test
    void contextLoads() {
    }

}


### File: dispensation-service/pom.xml
----------------------------------------
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="
           http://maven.apache.org/POM/4.0.0
           https://maven.apache.org/xsd/maven-4.0.0.xsd">

    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>tassproject.backend</groupId>
        <artifactId>backend</artifactId>
        <version>0.0.1-SNAPSHOT</version>
        <relativePath>../pom.xml</relativePath>
    </parent>

    <artifactId>dispensation-service</artifactId>
    <packaging>jar</packaging>
    <name>dispensation-service</name>

    <properties>
        <java.version>17</java.version>
    </properties>

    <dependencies>
        <!-- Core -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>

        <!-- Testing -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <!-- Testcontainers core -->
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>testcontainers</artifactId>
            <version>1.18.3</version>
            <scope>test</scope>
        </dependency>
        <!-- Testcontainers PostgreSQL module -->
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>postgresql</artifactId>
            <version>1.18.3</version>
            <scope>test</scope>
        </dependency>
        <!-- JUnit Jupiter integration for Testcontainers -->
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>junit-jupiter</artifactId>
            <version>1.18.3</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.amqp</groupId>
            <artifactId>spring-rabbit</artifactId>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
        </dependency>
        <!-- Actuator per health-check -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-config</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-oauth2-resource-server</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webflux</artifactId>
        </dependency>
        <!-- ★ Resource Server OAuth2 per Jwt -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
        </dependency>

        <!-- ★ JOSE support (JWT decoding) -->
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-oauth2-jose</artifactId>
        </dependency>

    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

</project>


### File: dispensation-service/src/main/java/tassproject/dispensationservice/AuthorizationService.java
----------------------------------------
package tassproject.dispensationservice.security;

import jakarta.annotation.Nonnull;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationToken;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;
import tassproject.dispensationservice.client.PrescriptionClient;
import tassproject.dispensationservice.repository.DispensationRepository;

import java.util.UUID;

@Component
@Transactional(readOnly = true)
public class AuthorizationService {

    private final DispensationRepository dispensations;
    private final PrescriptionClient prescriptions;   // ← nuovo client REST

    public AuthorizationService(DispensationRepository disp,
                                PrescriptionClient presc) {
        this.dispensations = disp;
        this.prescriptions = presc;
    }

    /* -------- utilities JWT -------- */
    private Authentication auth() {
        return org.springframework.security.core.context.SecurityContextHolder
                .getContext().getAuthentication();
    }

    private String role() {
        return auth().getAuthorities().stream()
                .map(GrantedAuthority::getAuthority).findFirst().orElse("");
    }

    private UUID userId() {
        var token = (JwtAuthenticationToken) auth();
        String id = token.getToken().getClaimAsString("citizen_id");
        if (id == null) throw new AccessDeniedException("Missing claim citizen_id");
        return UUID.fromString(id);
    }

    /* ---------- checks ------------ */
    public void assertCanAccessPharmacist(@Nonnull UUID pharmacistId) {
        switch (role()) {
            case "ROLE_PHARMACIST" -> {
                if (!userId().equals(pharmacistId))
                    deny("Puoi vedere solo i tuoi ordini.");
            }
            case "ROLE_ADMIN" -> { }
            default -> deny("Solo il farmacista interessato può accedere.");
        }
    }

    public void assertCanAccessPatient(@Nonnull UUID patientId) {
        switch (role()) {
            case "ROLE_PATIENT" -> {
                if (!userId().equals(patientId))
                    deny("Puoi vedere solo i tuoi dati.");
            }
            case "ROLE_PHARMACIST" -> {
                /* verifichiamo di aver dispensato al paziente */
                boolean served = dispensations.findByDispensedBy(userId()).stream()
                        .map(d -> prescriptions.getPrescription(d.getPrescriptionId()))
                        .filter(dto -> dto != null && dto.patientId().equals(patientId))
                        .findAny().isPresent();
                if (!served) deny("Non hai mai servito questo paziente.");
            }
            case "ROLE_ADMIN" -> { }
            default -> deny("Accesso non consentito.");
        }
    }

    private void deny(String msg) {
        throw new AccessDeniedException(msg);
    }
}


### File: dispensation-service/src/main/java/tassproject/dispensationservice/CreateDispensationRequest.java
----------------------------------------
package tassproject.dispensationservice;

import jakarta.validation.constraints.NotNull;
import java.util.UUID;

public record CreateDispensationRequest(@NotNull UUID prescriptionId, @NotNull UUID dispensedBy) {}

### File: dispensation-service/src/main/java/tassproject/dispensationservice/Dispensation.java
----------------------------------------
package tassproject.dispensationservice;

import jakarta.persistence.*;
import java.time.OffsetDateTime;
import java.util.UUID;

@Entity
@Table(name = "dispensations")
public class Dispensation {

    @Id
    @Column(columnDefinition = "uuid")
    private UUID id;

    // Riferimento alla Prescription via UUID, non l’entità JPA di un altro microservizio
    @Column(name = "prescription_id", nullable = false, columnDefinition = "uuid")
    private UUID prescriptionId;

    @Column(name = "dispensed_at", nullable = false)
    private OffsetDateTime dispensedAt;

    @Column(name = "dispensed_by", nullable = false, columnDefinition = "uuid")
    private UUID dispensedBy;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private Status status;

    public enum Status {
        DONE,
        FAILED
    }

    public Dispensation() {}

    public Dispensation(UUID id, UUID prescriptionId, OffsetDateTime dispensedAt, UUID dispensedBy, Status status) {
        this.id = id;
        this.prescriptionId = prescriptionId;
        this.dispensedAt = dispensedAt;
        this.dispensedBy = dispensedBy;
        this.status = status;
    }

    public UUID getId() {
        return id;
    }

    public void setId(UUID id) {
        this.id = id;
    }

    public UUID getPrescriptionId() {
        return prescriptionId;
    }

    public void setPrescriptionId(UUID prescriptionId) {
        this.prescriptionId = prescriptionId;
    }

    public OffsetDateTime getDispensedAt() {
        return dispensedAt;
    }

    public void setDispensedAt(OffsetDateTime dispensedAt) {
        this.dispensedAt = dispensedAt;
    }

    public UUID getDispensedBy() {
        return dispensedBy;
    }

    public void setDispensedBy(UUID dispensedBy) {
        this.dispensedBy = dispensedBy;
    }

    public Status getStatus() {
        return status;
    }

    public void setStatus(Status status) {
        this.status = status;
    }
}


### File: dispensation-service/src/main/java/tassproject/dispensationservice/DispensationApplicationService.java
----------------------------------------
package tassproject.dispensationservice;

import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import tassproject.dispensationservice.client.PrescriptionClient;
import tassproject.dispensationservice.repository.DispensationRepository;

import java.time.OffsetDateTime;
import java.util.List;
import java.util.UUID;

@Service
@Transactional
public class DispensationApplicationService {

    private final DispensationRepository repo;
    private final PrescriptionClient prescriptions;   // ← nuovo client REST
    private final RabbitTemplate rabbitTemplate;

    public DispensationApplicationService(DispensationRepository repo,
                                          PrescriptionClient prescriptions,
                                          RabbitTemplate rabbitTemplate) {
        this.repo           = repo;
        this.prescriptions  = prescriptions;
        this.rabbitTemplate = rabbitTemplate;
    }

    /* ------------------------- CREA ------------------------- */
    public DispensationResponse dispense(CreateDispensationRequest request) {
        var entity = new Dispensation(
                UUID.randomUUID(),
                request.prescriptionId(),
                OffsetDateTime.now(),
                request.dispensedBy(),
                Dispensation.Status.DONE);

        entity = repo.save(entity);
        rabbitTemplate.convertAndSend("dispensation.events",
                "PrescriptionDispensed",
                entity.getPrescriptionId());
        return DispensationResponse.from(entity);
    }

    /* --------------------- QUERY BASE ----------------------- */
    @Transactional(readOnly = true)
    public List<DispensationResponse> listByPrescription(UUID prescriptionId) {
        return repo.findByPrescriptionIdIn(List.of(prescriptionId))
                .stream().map(DispensationResponse::from).toList();
    }

    /* 4) ordini di un farmacista */
    @Transactional(readOnly = true)
    public List<DispensationResponse> listByPharmacist(UUID pharmacistId) {
        return repo.findByDispensedBy(pharmacistId)
                .stream().map(DispensationResponse::from).toList();
    }

    /* 2) pazienti serviti da un farmacista */
    @Transactional(readOnly = true)
    public List<UUID> patientsByPharmacist(UUID pharmacistId) {
        return repo.findByDispensedBy(pharmacistId).stream()
                .map(Dispensation::getPrescriptionId)
                .map(prescriptions::getPrescription)          // REST call
                .filter(dto -> dto != null)
                .map(PrescriptionClient.PrescriptionDTO::patientId)
                .distinct()
                .toList();
    }

    /* 2‑bis) farmacisti che hanno servito un paziente */
    @Transactional(readOnly = true)
    public List<UUID> pharmacistsByPatient(UUID patientId) {
        List<UUID> prescIds = prescriptions.listPrescriptionIdsByPatient(patientId);
        if (prescIds == null || prescIds.isEmpty()) return List.of();

        return repo.findByPrescriptionIdIn(prescIds).stream()
                .map(Dispensation::getDispensedBy)
                .distinct()
                .toList();
    }
}


### File: dispensation-service/src/main/java/tassproject/dispensationservice/DispensationController.java
----------------------------------------
package tassproject.dispensationservice;

import jakarta.validation.Valid;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.server.ResponseStatusException;
import tassproject.dispensationservice.client.PrescriptionClient;
import tassproject.dispensationservice.security.AuthorizationService;

import java.util.List;
import java.util.UUID;

@RestController
@RequestMapping("/api/v1")
public class DispensationController {

    private final DispensationApplicationService service;
    private final AuthorizationService           authz;
    private final PrescriptionClient             prescriptions;   // ← nuovo

    public DispensationController(DispensationApplicationService service,
                                  AuthorizationService authz,
                                  PrescriptionClient prescriptions) {
        this.service        = service;
        this.authz          = authz;
        this.prescriptions  = prescriptions;
    }

    /* ------------------------------ CREA ------------------------------ */
    @PostMapping("/dispensations")
    @ResponseStatus(HttpStatus.CREATED)
    public DispensationResponse dispense(@Valid @RequestBody CreateDispensationRequest body) {
        authz.assertCanAccessPharmacist(body.dispensedBy());
        return service.dispense(body);
    }

    /* -------------------------- QUERY PRESCRIZIONE -------------------- */
    @GetMapping("/prescriptions/{prescriptionId}/dispensations")
    public List<DispensationResponse> byPrescription(@PathVariable UUID prescriptionId) {
        var dto = prescriptions.getPrescription(prescriptionId);
        if (dto == null)
            throw new ResponseStatusException(HttpStatus.NOT_FOUND, "Prescrizione inesistente");

        authz.assertCanAccessPatient(dto.patientId());
        return service.listByPrescription(prescriptionId);
    }

    /* ------------------------------ NUOVI ENDPOINT -------------------- */
    @GetMapping("/pharmacists/{pharmacistId}/dispensations")
    public List<DispensationResponse> byPharmacist(@PathVariable UUID pharmacistId) {
        authz.assertCanAccessPharmacist(pharmacistId);
        return service.listByPharmacist(pharmacistId);
    }

    @GetMapping("/pharmacists/{pharmacistId}/patients")
    public List<UUID> patientsOfPharmacist(@PathVariable UUID pharmacistId) {
        authz.assertCanAccessPharmacist(pharmacistId);
        return service.patientsByPharmacist(pharmacistId);
    }

    @GetMapping("/patients/{patientId}/pharmacists")
    public List<UUID> pharmacistsOfPatient(@PathVariable UUID patientId) {
        authz.assertCanAccessPatient(patientId);
        return service.pharmacistsByPatient(patientId);
    }
}


### File: dispensation-service/src/main/java/tassproject/dispensationservice/DispensationRepository.java
----------------------------------------
package tassproject.dispensationservice.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import tassproject.dispensationservice.Dispensation;

import java.util.Collection;
import java.util.List;
import java.util.UUID;

public interface DispensationRepository extends JpaRepository<Dispensation, UUID> {

    /* 4) Ordini di un farmacista */
    List<Dispensation> findByDispensedBy(UUID pharmacistId);

    /* supporto a 2) / 6)  */
    List<Dispensation> findByPrescriptionIdIn(Collection<UUID> prescriptionIds);
}


### File: dispensation-service/src/main/java/tassproject/dispensationservice/DispensationResponse.java
----------------------------------------
package tassproject.dispensationservice;

import tassproject.dispensationservice.Dispensation;
import java.time.OffsetDateTime;
import java.util.UUID;

public record DispensationResponse(UUID id, UUID prescriptionId, OffsetDateTime dispensedAt, UUID dispensedBy, Dispensation.Status status) {
    public static DispensationResponse from(Dispensation d) {
        return new DispensationResponse(d.getId(), d.getPrescriptionId(), d.getDispensedAt(), d.getDispensedBy(), d.getStatus());
    }
}

### File: dispensation-service/src/main/java/tassproject/dispensationservice/DispensationServiceApplication.java
----------------------------------------
package tassproject.dispensationservice;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.domain.EntityScan;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;

@SpringBootApplication(
        // Se hai anche componenti (ad es. @Service, @Component) in prescription-service
        scanBasePackages = {
                "tassproject.dispensationservice",
                "tassproject.prescriptionservice"
        }
)
@EntityScan(basePackages = {
        "tassproject.dispensationservice",     // le tue entità locali
        "tassproject.prescriptionservice"      // quelle di Prescription
})
@EnableJpaRepositories(basePackages = {
        "tassproject.dispensationservice.repository",   // i repo di Dispensation
        "tassproject.prescriptionservice.repository"   // i repo di Prescription
})
public class DispensationServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(DispensationServiceApplication.class, args);
    }

}


### File: dispensation-service/src/main/java/tassproject/dispensationservice/PrescriptionClient.java
----------------------------------------
package tassproject.dispensationservice.client;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import org.springframework.web.reactive.function.client.WebClient;

import java.util.List;
import java.util.UUID;

/** Client REST minimale verso prescription‑service (solo ciò che serve a dispensation‑service). */
@Component
public class PrescriptionClient {

    private final WebClient webClient;

    public PrescriptionClient(
            @Value("${prescription-service.base-url:http://prescription-service:8080}")
            String baseUrl) {

        this.webClient = WebClient.builder()
                .baseUrl(baseUrl)
                .build();
    }

    /* DTO locale; evita di importare classi di un altro microservizio */
    public record PrescriptionDTO(UUID id, UUID patientId, UUID doctorId) {}

    /** Restituisce i dati minimi di una prescrizione. */
    public PrescriptionDTO getPrescription(UUID id) {
        return webClient.get()
                .uri("/api/v1/prescriptions/{id}", id)
                .retrieve()
                .bodyToMono(PrescriptionDTO.class)
                .block();
    }

    /** Elenco (solo id) di tutte le prescrizioni di un paziente – ci basta per query aggregata. */
    public List<UUID> listPrescriptionIdsByPatient(UUID patientId) {
        return webClient.get()
                .uri("/api/v1/patients/{patientId}/prescriptions", patientId)
                .retrieve()
                .bodyToFlux(PrescriptionDTO.class)
                .map(PrescriptionDTO::id)
                .collectList()
                .block();
    }
}


### File: dispensation-service/src/main/java/tassproject/dispensationservice/RabbitConfig.java
----------------------------------------
package tassproject.dispensationservice;

import org.springframework.amqp.core.Binding;
import org.springframework.amqp.core.BindingBuilder;
import org.springframework.amqp.core.Exchange;
import org.springframework.amqp.core.ExchangeBuilder;
import org.springframework.amqp.core.Queue;
import org.springframework.amqp.core.QueueBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class RabbitConfig {

    @Bean
    public Exchange dispensationExchange() {
        return ExchangeBuilder
                .topicExchange("dispensation.events")
                .durable(true)
                .build();
    }

    @Bean
    public Queue dispensationQueue() {
        return QueueBuilder
                .durable("dispensation.queue")
                .build();
    }

    @Bean
    public Binding bindDispensationEvents(Queue dispensationQueue, Exchange dispensationExchange) {
        return BindingBuilder
                .bind(dispensationQueue)
                .to(dispensationExchange)
                .with("#")
                .noargs();
    }
}


### File: dispensation-service/src/main/java/tassproject/dispensationservice/SecurityConfig.java
----------------------------------------
package tassproject.dispensationservice;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.Customizer;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.oauth2.jwt.NimbusJwtDecoder;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter;
import org.springframework.security.oauth2.server.resource.authentication.JwtGrantedAuthoritiesConverter;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
@EnableMethodSecurity
public class SecurityConfig {

    /** Converte il claim “role” del JWT in autorità Spring Security ROLE_… */
    private JwtAuthenticationConverter jwtAuthenticationConverter() {
        JwtGrantedAuthoritiesConverter converter = new JwtGrantedAuthoritiesConverter();
        converter.setAuthorityPrefix("ROLE_");
        converter.setAuthoritiesClaimName("role");

        JwtAuthenticationConverter jwtConv = new JwtAuthenticationConverter();
        jwtConv.setJwtGrantedAuthoritiesConverter(converter);
        return jwtConv;
    }

    @Bean
    SecurityFilterChain apiSecurity(HttpSecurity http) throws Exception {
        http
                .csrf(csrf -> csrf.disable())
                .sessionManagement(sm -> sm.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .authorizeHttpRequests(reg -> reg
                        .requestMatchers("/actuator/**", "/v3/api-docs/**", "/swagger-ui/**").permitAll()
                        .anyRequest().authenticated()
                )
                .oauth2ResourceServer(oauth -> oauth
                        .jwt(jwt -> jwt.jwtAuthenticationConverter(jwtAuthenticationConverter()))
                )
                .httpBasic(Customizer.withDefaults());

        return http.build();
    }

    /**
     * Definisce il bean JwtDecoder per firmare/verificare token HMAC‑SHA256
     * usando la chiave fornita tramite property/env var “jwt.secret”.
     */
    @Bean
    public JwtDecoder jwtDecoder(@Value("${jwt.secret:my_jwt_secret}") String secret) {
        byte[] keyBytes;
        try {
            keyBytes = java.util.Base64.getDecoder().decode(secret);
        } catch (IllegalArgumentException ex) {
            keyBytes = secret.getBytes(java.nio.charset.StandardCharsets.UTF_8);
        }
        javax.crypto.SecretKey key = new javax.crypto.spec.SecretKeySpec(keyBytes, "HmacSHA256");
        return NimbusJwtDecoder.withSecretKey(key).build();
    }
}


### File: dispensation-service/src/main/resources/application.properties
----------------------------------------
spring.application.name=dispensation-service
server.port=${SERVER_PORT:8080}

spring.datasource.url=${SPRING_DATASOURCE_URL:jdbc:postgresql://localhost:5432/mydatabase}
spring.datasource.username=${SPRING_DATASOURCE_USERNAME:myuser}
spring.datasource.password=${SPRING_DATASOURCE_PASSWORD:secret}
spring.datasource.driver-class-name=org.postgresql.Driver

spring.jpa.hibernate.ddl-auto=${SPRING_JPA_HIBERNATE_DDL_AUTO:update}
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.properties.hibernate.default_schema=dispensation_service 

management.endpoints.web.exposure.include=health,info

# HikariCP (opzionale)
spring.datasource.hikari.maximum-pool-size=10
spring.datasource.hikari.minimum-idle=2
spring.datasource.hikari.idle-timeout=300000
spring.datasource.hikari.max-lifetime=600000

jwt.secret=${JWT_SECRET:my_jwt_secret}
jwt.expiration=${JWT_EXPIRATION_MS:3600000}

### File: dispensation-service/src/main/resources/application.yml
----------------------------------------
spring:
  application:
    name: dispensation-service

# base‑url interno (default nel compose/network)
prescription-service:
  base-url: ${PRESCRIPTION_SERVICE_URL:http://prescription-service:8080}


### File: dispensation-service/src/test/java/tassproject/dispensationservice/DispensationRepositoryIT.java
----------------------------------------
package tassproject.dispensationservice;

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;
import org.springframework.test.context.DynamicPropertyRegistry;
import org.springframework.test.context.DynamicPropertySource;
import org.testcontainers.containers.PostgreSQLContainer;
import org.testcontainers.junit.jupiter.Container;
import org.testcontainers.junit.jupiter.Testcontainers;

import java.time.OffsetDateTime;
import java.util.UUID;

@Testcontainers
@DataJpaTest
class DispensationRepositoryIT {

    @Container
    static PostgreSQLContainer<?> postgres =
            new PostgreSQLContainer<>("postgres:16-alpine")
                    .withDatabaseName("db")
                    .withUsername("user")
                    .withPassword("pwd");

    @DynamicPropertySource
    static void overrideProps(DynamicPropertyRegistry registry) {
        registry.add("spring.datasource.url",      postgres::getJdbcUrl);
        registry.add("spring.datasource.username", postgres::getUsername);
        registry.add("spring.datasource.password", postgres::getPassword);
    }

    @Autowired
    private tassproject.dispensationservice.repository.DispensationRepository repo;

    @Test
    void saveAndQuery() {
        var disp = new Dispensation(
                UUID.randomUUID(),
                UUID.randomUUID(),
                OffsetDateTime.now(),
                UUID.randomUUID(),
                Dispensation.Status.DONE
        );
        repo.save(disp);

        Assertions.assertEquals(1, repo.findAll().size());
        Assertions.assertTrue(repo.existsById(disp.getId()));
    }
}


### File: dispensation-service/src/test/java/tassproject/dispensationservice/DispensationServiceApplicationTests.java
----------------------------------------
package tassproject.dispensationservice;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class DispensationServiceApplicationTests {

    @Test
    void contextLoads() {
    }
}


### File: inventory-service/pom.xml
----------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
                             https://maven.apache.org/xsd/maven-4.0.0.xsd">

    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>tassproject.backend</groupId>
        <artifactId>backend</artifactId>
        <version>0.0.1-SNAPSHOT</version>
        <relativePath>../pom.xml</relativePath>
    </parent>

    <artifactId>inventory-service</artifactId>
    <packaging>jar</packaging>
    <name>inventory-service</name>

    <properties>
        <java.version>17</java.version>
        <testcontainers.version>1.18.3</testcontainers.version>
    </properties>

    <dependencies>
        <!-- Core -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>


        <dependency>
            <groupId>org.flywaydb</groupId>
            <artifactId>flyway-core</artifactId>
        </dependency>

        <!-- Actuator -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>

        <!-- Test -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>testcontainers</artifactId>
            <version>${testcontainers.version}</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>postgresql</artifactId>
            <version>${testcontainers.version}</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>junit-jupiter</artifactId>
            <version>${testcontainers.version}</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>1.18.38</version>
            <scope>provided</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <!-- Lombok annotation processing -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.11.0</version>
                <configuration>
                    <annotationProcessorPaths>
                        <path>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                            <version>1.18.38</version>
                        </path>
                    </annotationProcessorPaths>
                    <release>${java.version}</release>
                </configuration>
            </plugin>

            <!-- Spring Boot -->
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <version>${spring-boot.version}</version>
                <executions>
                    <execution>
                        <goals><goal>repackage</goal></goals>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>

</project>


### File: inventory-service/src/main/java/tassproject/inventoryservice/AvailabilityResponse.java
----------------------------------------
package tassproject.inventoryservice;

import java.util.UUID;

public record AvailabilityResponse(UUID drugId, int quantity) {}

### File: inventory-service/src/main/java/tassproject/inventoryservice/GlobalExceptionHandler.java
----------------------------------------
package tassproject.inventoryservice;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;

/**
 * Trasforma le eccezioni di validazione in risposte HTTP leggibili.
 */
@ControllerAdvice
class GlobalExceptionHandler {

    @ExceptionHandler(IllegalArgumentException.class)
    ResponseEntity<ErrorDTO> handleBadRequest(IllegalArgumentException ex) {
        return ResponseEntity
                .status(HttpStatus.BAD_REQUEST)
                .body(new ErrorDTO(ex.getMessage()));
    }

    record ErrorDTO(String error) {}
}


### File: inventory-service/src/main/java/tassproject/inventoryservice/InventoryApplicationService.java
----------------------------------------
package tassproject.inventoryservice;

import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import tassproject.inventoryservice.InventoryItemRepository;

import java.time.OffsetDateTime;
import java.util.List;
import java.util.UUID;

@Service
@RequiredArgsConstructor
@Transactional
public class InventoryApplicationService {

    private final InventoryItemRepository repo;

    /* ===== lettura ===== */
    @Transactional(readOnly = true)
    public AvailabilityResponse checkAvailability(UUID drugId) {
        int qty = repo.findByDrugId(drugId)
                .map(InventoryItem::getAvailableQuantity)
                .orElse(0);
        return new AvailabilityResponse(drugId, qty);
    }

    /** Elenco completo (DTO) degli articoli di una farmacia. */
    @Transactional(readOnly = true)
    public List<InventoryItemResponse> listByPharmacy(UUID pharmacyId) {
        return repo.findByPharmacyId(pharmacyId).stream()
                .map(InventoryItemResponse::from)
                .toList();
    }

    /* ===== scrittura ===== */
    public void reserve(UUID drugId, int quantity, String reason) {
        var row = repo.findByDrugId(drugId)
                .orElseThrow(() -> new IllegalArgumentException(
                        "Il farmaco %s non è presente a magazzino".formatted(drugId)));
        if (row.getAvailableQuantity() < quantity)
            throw new IllegalArgumentException("Scorte insufficienti per la prenotazione");
        row.setAvailableQuantity(row.getAvailableQuantity() - quantity);
        row.setLastUpdated(OffsetDateTime.now());
        repo.save(row);
    }
}

### File: inventory-service/src/main/java/tassproject/inventoryservice/InventoryController.java
----------------------------------------
package tassproject.inventoryservice;

import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.UUID;

@RestController
@RequestMapping("/api/v1")
@RequiredArgsConstructor
public class InventoryController {

    private final InventoryApplicationService service;

    @GetMapping("/inventory/{drugId}/availability")
    public AvailabilityResponse availability(@PathVariable UUID drugId) {
        return service.checkAvailability(drugId);
    }

    @PostMapping("/inventory/items/{drugId}/reserve")
    @ResponseStatus(HttpStatus.NO_CONTENT)
    public void reserve(@PathVariable UUID drugId, @RequestBody ReserveInventoryRequest body) {
        service.reserve(drugId, body.quantity(), body.reason());
    }

    /* ===== NUOVO: inventario di una farmacia dato il farmacista (frontend passa l’ID farmacia) */
    @GetMapping("/pharmacists/{pharmacistId}/pharmacies/{pharmacyId}/inventory")
    public List<InventoryItemResponse> inventoryByPharmacy(
            @PathVariable UUID pharmacistId,
            @PathVariable UUID pharmacyId) {
        // Eventuale authorization layer qui …
        return service.listByPharmacy(pharmacyId);
    }
}


### File: inventory-service/src/main/java/tassproject/inventoryservice/InventoryItem.java
----------------------------------------
package tassproject.inventoryservice;

import jakarta.persistence.*;
import java.time.OffsetDateTime;
import java.util.UUID;

@Entity
@Table(name = "inventory_items")
public class InventoryItem {

    @Id
    @Column(columnDefinition = "uuid")
    private UUID id;

    @Column(name = "drug_id", nullable = false, columnDefinition = "uuid")
    private UUID drugId;

    @Column(name = "pharmacy_id", nullable = false, columnDefinition = "uuid")   // 🆕
    private UUID pharmacyId;

    @Column(name = "available_quantity", nullable = false)
    private int availableQuantity;

    @Column(name = "last_updated", nullable = false)
    private OffsetDateTime lastUpdated;

    protected InventoryItem() {}

    public InventoryItem(UUID id, UUID drugId, UUID pharmacyId, int availableQuantity, OffsetDateTime lastUpdated) {
        this.id = id;
        this.drugId = drugId;
        this.pharmacyId = pharmacyId;
        this.availableQuantity = availableQuantity;
        this.lastUpdated = lastUpdated;
    }

    // -------- getters/setters --------
    public UUID getId() { return id; }
    public void setId(UUID id) { this.id = id; }

    public UUID getDrugId() { return drugId; }
    public void setDrugId(UUID drugId) { this.drugId = drugId; }

    public UUID getPharmacyId() { return pharmacyId; }
    public void setPharmacyId(UUID pharmacyId) { this.pharmacyId = pharmacyId; }

    public int getAvailableQuantity() { return availableQuantity; }
    public void setAvailableQuantity(int availableQuantity) { this.availableQuantity = availableQuantity; }

    public OffsetDateTime getLastUpdated() { return lastUpdated; }
    public void setLastUpdated(OffsetDateTime lastUpdated) { this.lastUpdated = lastUpdated; }
}


### File: inventory-service/src/main/java/tassproject/inventoryservice/InventoryItemRepository.java
----------------------------------------
package tassproject.inventoryservice;

import org.springframework.data.jpa.repository.JpaRepository;
import tassproject.inventoryservice.InventoryItem;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

public interface InventoryItemRepository extends JpaRepository<InventoryItem, UUID> {
    Optional<InventoryItem> findByDrugId(UUID drugId);
    List<InventoryItem>     findByPharmacyId(UUID pharmacyId); }

### File: inventory-service/src/main/java/tassproject/inventoryservice/InventoryItemResponse.java
----------------------------------------
package tassproject.inventoryservice;

import java.time.OffsetDateTime;
import java.util.UUID;

public record InventoryItemResponse(UUID id, UUID drugId, int availableQuantity, OffsetDateTime lastUpdated) {
    public static InventoryItemResponse from(InventoryItem i) {
        return new InventoryItemResponse(i.getId(), i.getDrugId(), i.getAvailableQuantity(), i.getLastUpdated());
    }
}

### File: inventory-service/src/main/java/tassproject/inventoryservice/InventoryServiceApplication.java
----------------------------------------
package tassproject.inventoryservice;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class InventoryServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(InventoryServiceApplication.class, args);
    }

}


### File: inventory-service/src/main/java/tassproject/inventoryservice/Pharmacy.java
----------------------------------------
package tassproject.inventoryservice;

import jakarta.persistence.*;
import java.util.UUID;

@Entity
@Table(name = "pharmacies")
public class Pharmacy {
    @Id
    @Column(columnDefinition = "uuid")
    private UUID id;

    private String nome;
    private String indirizzo;

    protected Pharmacy() {}
    public Pharmacy(UUID id, String nome, String indirizzo) {
        this.id = id;
        this.nome = nome;
        this.indirizzo = indirizzo;
    }

    public UUID getId() { return id; }
    public String getNome() { return nome; }
    public String getIndirizzo() { return indirizzo; }
}

### File: inventory-service/src/main/java/tassproject/inventoryservice/ReserveInventoryRequest.java
----------------------------------------
package tassproject.inventoryservice;

import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotBlank;

public record ReserveInventoryRequest(
        @Min(1) int quantity,
        @NotBlank String reason) {}


### File: inventory-service/src/main/resources/application.properties
----------------------------------------
spring.application.name=inventory-service
server.port=${SERVER_PORT:8080}


spring.datasource.url=${SPRING_DATASOURCE_URL:jdbc:postgresql://localhost:5432/mydatabase}
spring.datasource.username=${SPRING_DATASOURCE_USERNAME:myuser}
spring.datasource.password=${SPRING_DATASOURCE_PASSWORD:secret}
spring.datasource.driver-class-name=org.postgresql.Driver


spring.flyway.enabled=true
spring.flyway.baseline-on-migrate=true
spring.flyway.baseline-version=0
spring.flyway.schemas=inventory_service

spring.flyway.locations=classpath:db/migration



spring.jpa.hibernate.ddl-auto=validate
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.properties.hibernate.default_schema=inventory_service


management.endpoints.web.exposure.include=health,info


spring.datasource.hikari.maximum-pool-size=10
spring.datasource.hikari.minimum-idle=2
spring.datasource.hikari.idle-timeout=300000
spring.datasource.hikari.max-lifetime=600000


jwt.secret=${JWT_SECRET:my_jwt_secret}
jwt.expiration=${JWT_EXPIRATION_MS:3600000}


### File: inventory-service/src/main/resources/db/migration/V1__drop_inventory_items_drug_fk.sql
----------------------------------------
-- Rimuove il vecchio vincolo che puntava alla tabella inesistente "drugs"
ALTER TABLE IF EXISTS inventory_service.inventory_items
    DROP CONSTRAINT IF EXISTS inventory_items_drug_id_fkey;


### File: inventory-service/src/main/resources/db/migration/V2__add_pharmacy_id_to_inventory.sql
----------------------------------------
BEGIN;

-- 1) Aggiungi prima la colonna nullable
ALTER TABLE inventory_service.inventory_items
    ADD COLUMN pharmacy_id UUID;

-- 2) Popola il campo per le righe esistenti
UPDATE inventory_service.inventory_items
SET pharmacy_id = '00000000-0000-0000-0000-000000000000'
WHERE pharmacy_id IS NULL;

-- 3) Imposta la colonna NOT NULL
ALTER TABLE inventory_service.inventory_items
    ALTER COLUMN pharmacy_id SET NOT NULL;

COMMIT;


### File: inventory-service/src/test/java/tassproject/inventoryservice/InventoryItemRepositoryIT.java
----------------------------------------
package tassproject.inventoryservice;

import org.junit.jupiter.api.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;
import org.springframework.test.context.DynamicPropertyRegistry;
import org.springframework.test.context.DynamicPropertySource;
import org.testcontainers.containers.PostgreSQLContainer;
import org.testcontainers.junit.jupiter.Container;
import org.testcontainers.junit.jupiter.Testcontainers;
import tassproject.inventoryservice.InventoryItemRepository;

import java.time.OffsetDateTime;
import java.util.UUID;

@Testcontainers
@DataJpaTest
class InventoryItemRepositoryIT {

    @Container
    static PostgreSQLContainer<?> postgres =
            new PostgreSQLContainer<>("postgres:16-alpine")
                    .withDatabaseName("db")
                    .withUsername("user")
                    .withPassword("pwd");

    @DynamicPropertySource
    static void props(DynamicPropertyRegistry r) {
        r.add("spring.datasource.url", postgres::getJdbcUrl);
        r.add("spring.datasource.username", postgres::getUsername);
        r.add("spring.datasource.password", postgres::getPassword);
    }

    @Autowired
    InventoryItemRepository repo;

    @Test
    void positiveStockUpdate() {
        var row = new InventoryItem();
        row.setId(UUID.randomUUID());
        row.setDrugId(UUID.randomUUID());
        row.setAvailableQuantity(10);
        row.setLastUpdated(OffsetDateTime.now());

        repo.save(row);

        var loaded = repo.findById(row.getId()).orElseThrow();
        loaded.setAvailableQuantity(loaded.getAvailableQuantity() + 5);
        repo.save(loaded);

        Assertions.assertEquals(15, repo.findById(row.getId()).orElseThrow().getAvailableQuantity());
    }
}


### File: inventory-service/src/test/java/tassproject/inventoryservice/InventoryServiceApplicationTests.java
----------------------------------------
package tassproject.inventoryservice;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class InventoryServiceApplicationTests {

    @Test
    void contextLoads() {
    }

}


### File: notification-service/pom.xml
----------------------------------------
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
                             https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <!-- 1) Ereditamo dal parent aggregator -->
    <parent>
        <groupId>tassproject.backend</groupId>
        <artifactId>backend</artifactId>
        <version>0.0.1-SNAPSHOT</version>
        <relativePath>../pom.xml</relativePath>
    </parent>

    <!-- 2) Coordinate di questo modulo -->
    <groupId>tassproject.backend</groupId>
    <artifactId>notification-service</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <packaging>jar</packaging>
    <name>notification-service</name>

    <properties>
        <java.version>17</java.version>
    </properties>

    <dependencies>
        <!-- Core Spring Boot + REST/RabbitMQ -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-amqp</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>

        <!-- Lombok -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>1.18.38</version>
            <scope>provided</scope>
        </dependency>

        <!-- Test -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <!-- Actuator per health-check -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>

    </dependencies>

    <build>
        <plugins>
            <!-- Lombok annotation processing -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.11.0</version>
                <configuration>
                    <annotationProcessorPaths>
                        <path>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                            <version>1.18.38</version>
                        </path>
                    </annotationProcessorPaths>
                    <release>${java.version}</release>
                </configuration>
            </plugin>
            <!-- Spring Boot -->
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>


### File: notification-service/src/main/java/tassproject/notificationservice/NotificationController.java
----------------------------------------
package tassproject.notificationservice;

import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.*;
import tassproject.notificationservice.SendNotificationRequest;

@RestController
@RequestMapping("/api/v1")
@RequiredArgsConstructor
public class NotificationController {
    private final RabbitTemplate rabbitTemplate;

    @PostMapping("/notifications")
    @ResponseStatus(HttpStatus.ACCEPTED)
    public void notify(@Valid @RequestBody SendNotificationRequest request) {
        rabbitTemplate.convertAndSend("notification.events", request.type().name(), request);
    }
}


### File: notification-service/src/main/java/tassproject/notificationservice/NotificationServiceApplication.java
----------------------------------------
package tassproject.notificationservice;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class NotificationServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(NotificationServiceApplication.class, args);
    }

}


### File: notification-service/src/main/java/tassproject/notificationservice/RabbitConfig.java
----------------------------------------
package tassproject.notificationservice;

import org.springframework.amqp.core.Binding;
import org.springframework.amqp.core.BindingBuilder;
import org.springframework.amqp.core.Exchange;
import org.springframework.amqp.core.ExchangeBuilder;
import org.springframework.amqp.core.Queue;
import org.springframework.amqp.core.QueueBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class RabbitConfig {

    @Bean
    public Exchange notificationExchange() {
        return ExchangeBuilder
                .directExchange("notification.events")
                .durable(true)
                .build();
    }

    @Bean
    public Queue notificationQueue() {
        return QueueBuilder
                .durable("notification.queue")
                .build();
    }

    @Bean
    public Binding bindNotification(Queue notificationQueue, Exchange notificationExchange) {
        return BindingBuilder
                .bind(notificationQueue)
                .to(notificationExchange)
                .with("INFO")
                .noargs();
    }
}


### File: notification-service/src/main/java/tassproject/notificationservice/SendNotificationRequest.java
----------------------------------------
package tassproject.notificationservice;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import java.io.Serializable;          // 👈 nuovo import
import java.util.UUID;

public record SendNotificationRequest(
        @NotNull  UUID  recipientId,
        @NotBlank String message,
        @NotNull  Type   type)
        implements Serializable {     // 👈 implementa Serializable

    public enum Type { INFO, WARNING, ERROR }
}


### File: notification-service/src/main/resources/application.properties
----------------------------------------
spring.application.name=notification-service
server.port=${SERVER_PORT:8080}

spring.datasource.url=${SPRING_DATASOURCE_URL:jdbc:postgresql://localhost:5432/mydatabase}
spring.datasource.username=${SPRING_DATASOURCE_USERNAME:myuser}
spring.datasource.password=${SPRING_DATASOURCE_PASSWORD:secret}
spring.datasource.driver-class-name=org.postgresql.Driver

spring.jpa.hibernate.ddl-auto=${SPRING_JPA_HIBERNATE_DDL_AUTO:update}
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.properties.hibernate.default_schema=notification_service

management.endpoints.web.exposure.include=health,info

# HikariCP (opzionale)
spring.datasource.hikari.maximum-pool-size=10
spring.datasource.hikari.minimum-idle=2
spring.datasource.hikari.idle-timeout=300000
spring.datasource.hikari.max-lifetime=600000

jwt.secret=${JWT_SECRET:my_jwt_secret}
jwt.expiration=${JWT_EXPIRATION_MS:3600000}

### File: notification-service/src/test/java/tassproject/notificationservice/NotificationServiceApplicationTests.java
----------------------------------------
package tassproject.notificationservice;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class NotificationServiceApplicationTests {

    @Test
    void contextLoads() {
    }

}


### File: pharma-service/pom.xml
----------------------------------------
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
                             https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <!-- 1) Parent: aggregatore backend che include Spring Boot parent e BOM -->
    <parent>
        <groupId>tassproject.backend</groupId>
        <artifactId>backend</artifactId>
        <version>0.0.1-SNAPSHOT</version>
        <relativePath>../pom.xml</relativePath>
    </parent>

    <!-- 2) Coordinate del modulo -->
    <groupId>it.mycompany</groupId>
    <artifactId>pharma-service</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>Pharma Service</name>
    <description>Microservizio per gestione farmaci, principi attivi e famiglie farmaceutiche.</description>
    <packaging>jar</packaging>

    <!-- 3) Imposta Java 17 per compile & test -->
    <properties>
        <java.version>17</java.version>
        <maven.compiler.release>${java.version}</maven.compiler.release>
        <spring-boot.version>3.1.1</spring-boot.version>
    </properties>

    <!-- 4) Dipendenze principali -->
    <dependencies>
        <!-- Web MVC e Reactor (WebFlux) -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webflux</artifactId>
        </dependency>
        <!-- JPA / Hibernate -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <!-- Validazione Bean -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
        <!-- Security (JWT + roles) -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        <!-- PostgreSQL Driver -->
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>
        <!-- Lombok per ridurre boilerplate -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>

        <!-- CLIENT per chiamate ad altri microservizi (su WebClient) -->
        <dependency>
            <groupId>io.projectreactor.netty</groupId>
            <artifactId>reactor-netty-http</artifactId>
        </dependency>

        <!-- Test -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
            <exclusions>
                <exclusion>
                    <groupId>org.junit.vintage</groupId>
                    <artifactId>junit-vintage-engine</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
        <!-- Starter per WebFlux + Security JWT -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
        </dependency>
        <!-- Supporto JOSE / JWT -->
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-oauth2-jose</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-oauth2-jose</artifactId>
        </dependency>
    </dependencies>

    <!-- 5) Plugin di build -->
    <build>
        <plugins>
            <!-- Spring Boot: packaging eseguibile -->
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <version>${spring-boot.version}</version>
                <executions>
                    <execution>
                        <goals>
                            <goal>repackage</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>

            <!-- Compiler: assicura Java 17 -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.10.1</version>
                <configuration>
                    <release>${java.version}</release>
                    <parameters>true</parameters>
                </configuration>
            </plugin>
        </plugins>
    </build>

    <!-- 6) Gestione dei repository (se hai repository interni) -->
    <!--
    <repositories>
      <repository>
        <id>company-repo</id>
        <url>https://repo.mycompany.it/maven2</url>
      </repository>
    </repositories>
    -->
</project>


### File: pharma-service/src/main/java/tassproject/pharmaservice/ActiveIngredient.java
----------------------------------------
package tassproject.pharmaservice;

import jakarta.persistence.*;
import lombok.*;

import java.util.UUID;

@Entity
@Table(name = "active_ingredients", schema = "pharma_service")
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ActiveIngredient {

    @Id
    @Column(columnDefinition = "uuid")
    private UUID id;

    private String nome;

    private String descrizione;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "famiglia_id")
    private PharmaFamily famiglia;
}

### File: pharma-service/src/main/java/tassproject/pharmaservice/ActiveIngredientController.java
----------------------------------------
package tassproject.pharmaservice;

import tassproject.pharmaservice.ActiveIngredientResponse;
import tassproject.pharmaservice.ActiveIngredientService;
import lombok.RequiredArgsConstructor;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@RestController
@RequestMapping("/api/v1/active-ingredients")
@RequiredArgsConstructor
public class ActiveIngredientController {

    private final ActiveIngredientService service;

    @GetMapping
    public List<ActiveIngredientResponse> list() {
        return service.listAll();
    }
}


### File: pharma-service/src/main/java/tassproject/pharmaservice/ActiveIngredientRepository.java
----------------------------------------
package tassproject.pharmaservice;

import tassproject.pharmaservice.ActiveIngredient;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.UUID;

public interface ActiveIngredientRepository extends JpaRepository<ActiveIngredient, UUID> {
}

### File: pharma-service/src/main/java/tassproject/pharmaservice/ActiveIngredientResponse.java
----------------------------------------
package tassproject.pharmaservice;

import tassproject.pharmaservice.ActiveIngredient;

import java.util.UUID;

public record ActiveIngredientResponse(UUID id, String nome, String descrizione, UUID famigliaId) {
    public static ActiveIngredientResponse from(ActiveIngredient a) {
        return new ActiveIngredientResponse(a.getId(), a.getNome(), a.getDescrizione(),
                a.getFamiglia() != null ? a.getFamiglia().getId() : null);
    }
}

### File: pharma-service/src/main/java/tassproject/pharmaservice/ActiveIngredientService.java
----------------------------------------
package tassproject.pharmaservice;

import tassproject.pharmaservice.ActiveIngredientResponse;
import tassproject.pharmaservice.ActiveIngredient;
import tassproject.pharmaservice.ActiveIngredientRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.UUID;

@Service
@RequiredArgsConstructor
public class ActiveIngredientService {

    private final ActiveIngredientRepository repo;

    public ActiveIngredient get(UUID id) {
        return repo.findById(id).orElseThrow(() -> new IllegalArgumentException("Active ingredient not found: " + id));
    }

    public List<ActiveIngredientResponse> listAll() {
        return repo.findAll().stream().map(ActiveIngredientResponse::from).toList();
    }
}



### File: pharma-service/src/main/java/tassproject/pharmaservice/Drug.java
----------------------------------------
package tassproject.pharmaservice;

import jakarta.persistence.*;
import lombok.*;

import java.math.BigDecimal;
import java.util.UUID;

@Entity
@Table(name = "drugs", schema = "pharma_service")
@Data                       // genera getter/setter per tutti i campi
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class Drug {

    /* ---------- PK ---------- */
    @Id
    @Column(columnDefinition = "uuid")
    private UUID id;

    /* ---------- Colonne semplici ---------- */
    @Column(name = "nome_commerciale")
    private String nomeCommerciale;

    private String produttore;

    @Column(name = "modo_somministrazione")
    private String modoSomministrazione;

    private BigDecimal prezzo;

    /* ---------- Relazione con ActiveIngredient ---------- */
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "principio_attivo_id")
    private ActiveIngredient principioAttivo;

    /* ------------------------------------------------------------------
       ALIAS per compatibilità: getActiveIngredient / setActiveIngredient
       ------------------------------------------------------------------ */

    /**
     * Alias di comodo per evitare LazyInitializationException
     * quando il codice legacy chiama getActiveIngredient().
     */
    public ActiveIngredient getActiveIngredient() {
        return this.principioAttivo;
    }

    /**
     * Alias corrispondente al setter.
     */
    public void setActiveIngredient(ActiveIngredient activeIngredient) {
        this.principioAttivo = activeIngredient;
    }
}


### File: pharma-service/src/main/java/tassproject/pharmaservice/DrugController.java
----------------------------------------
package tassproject.pharmaservice;

import lombok.RequiredArgsConstructor;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import reactor.core.publisher.Flux;

import java.util.UUID;

@RestController
@RequestMapping("/api/v1/drugs")
@RequiredArgsConstructor
public class DrugController {

    private final DrugService service;

    /**
     * Ritorna tutti i farmaci in modo reattivo.
     * Assicurati che DrugService abbia:
     *   public Flux<DrugResponse> list() { … }
     */
    @GetMapping
    public Flux<DrugResponse> listDrugs() {
        return service.list();
    }

    /**
     * Ritorna gli ActiveIngredientResponse di un farmaco.
     * Assicurati che DrugService abbia:
     *   public Flux<ActiveIngredientResponse> activeIngredients(UUID id) { … }
     */
    @GetMapping("/{id}/active-ingredients")
    public Flux<ActiveIngredientResponse> activeIngredients(@PathVariable UUID id) {
        return service.activeIngredients(id);
    }
}


### File: pharma-service/src/main/java/tassproject/pharmaservice/DrugRepository.java
----------------------------------------
package tassproject.pharmaservice;

import org.springframework.data.jpa.repository.EntityGraph;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;
import java.util.UUID;

@Repository
public interface DrugRepository extends JpaRepository<Drug, UUID> {

    /**
     * Carica il farmaco insieme al relativo principio attivo.
     * NOTA: il nome nell’EntityGraph deve corrispondere al
     * campo presente in `Drug` (principioAttivo).
     */
    @EntityGraph(attributePaths = "principioAttivo")
    Optional<Drug> findWithActiveIngredientById(UUID id);
}


### File: pharma-service/src/main/java/tassproject/pharmaservice/DrugResponse.java
----------------------------------------
package tassproject.pharmaservice;

import tassproject.pharmaservice.Drug;

import java.math.BigDecimal;
import java.util.UUID;

public record DrugResponse(UUID id, String nomeCommerciale, String produttore,
                           String modoSomministrazione, BigDecimal prezzo, UUID principioAttivoId) {
    public static DrugResponse from(Drug d) {
        return new DrugResponse(d.getId(), d.getNomeCommerciale(), d.getProduttore(),
                d.getModoSomministrazione(), d.getPrezzo(),
                d.getPrincipioAttivo() != null ? d.getPrincipioAttivo().getId() : null);
    }
}

### File: pharma-service/src/main/java/tassproject/pharmaservice/DrugService.java
----------------------------------------
package tassproject.pharmaservice;

import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.util.UUID;

@Service
@RequiredArgsConstructor
public class DrugService {

    private final DrugRepository drugRepository;

    /*------------------------------------------------------------------
     * LISTA COMPLETA DEI FARMACI (metodo mancante)
     *----------------------------------------------------------------*/
    public Flux<DrugResponse> list() {
        return Mono.fromCallable(drugRepository::findAll)   // blocco su thread worker
                .flatMapMany(Flux::fromIterable)         // → Flux<Drug>
                .map(DrugResponse::from);                // → Flux<DrugResponse>
    }

    /*------------------------------------------------------------------
     * PRINCIPIO ATTIVO DI UN SINGOLO FARMACO
     *----------------------------------------------------------------*/
    public Flux<ActiveIngredientResponse> activeIngredients(UUID drugId) {
        return Mono.fromCallable(() ->
                        drugRepository
                                .findWithActiveIngredientById(drugId)
                                .orElseThrow(() ->
                                        new ResourceNotFoundException("Drug", drugId)))
                .flatMapMany(drug ->
                        Flux.just(
                                ActiveIngredientResponse.from(
                                        drug.getPrincipioAttivo()   // <‑‑ nome corretto
                                )));
    }
}


### File: pharma-service/src/main/java/tassproject/pharmaservice/PharmaFamily.java
----------------------------------------
package tassproject.pharmaservice;

import jakarta.persistence.*;
import lombok.*;

import java.util.UUID;

@Entity
@Table(name = "pharma_families", schema = "pharma_service")
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class PharmaFamily {

    @Id
    @Column(columnDefinition = "uuid")
    private UUID id;

    private String nome;

    private String descrizione;
}

### File: pharma-service/src/main/java/tassproject/pharmaservice/PharmaFamilyController.java
----------------------------------------
package tassproject.pharmaservice;

import tassproject.pharmaservice.PharmaFamilyResponse;
import tassproject.pharmaservice.PharmaFamily;
import tassproject.pharmaservice.PharmaFamilyRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@RestController
@RequestMapping("/api/v1/pharma-families")
@RequiredArgsConstructor
public class PharmaFamilyController {

    private final PharmaFamilyRepository repo;

    @GetMapping
    public List<PharmaFamilyResponse> list() {
        return repo.findAll().stream().map(PharmaFamilyResponse::from).toList();
    }
}

### File: pharma-service/src/main/java/tassproject/pharmaservice/PharmaFamilyRepository.java
----------------------------------------
package tassproject.pharmaservice;

import tassproject.pharmaservice.PharmaFamily;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.UUID;

public interface PharmaFamilyRepository extends JpaRepository<PharmaFamily, UUID> {
}

### File: pharma-service/src/main/java/tassproject/pharmaservice/PharmaFamilyResponse.java
----------------------------------------
package tassproject.pharmaservice;

import tassproject.pharmaservice.PharmaFamily;

import java.util.UUID;

public record PharmaFamilyResponse(UUID id, String nome, String descrizione) {
    public static PharmaFamilyResponse from(PharmaFamily f) {
        return new PharmaFamilyResponse(f.getId(), f.getNome(), f.getDescrizione());
    }
}


### File: pharma-service/src/main/java/tassproject/pharmaservice/PharmaServiceApplication.java
----------------------------------------
package tassproject.pharmaservice;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class PharmaServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(PharmaServiceApplication.class, args);
    }
}

### File: pharma-service/src/main/java/tassproject/pharmaservice/ResourceNotFoundException.java
----------------------------------------
package tassproject.pharmaservice;

/**
 * Eccezione lanciata quando non si trova una risorsa.
 */
public class ResourceNotFoundException extends RuntimeException {

    public ResourceNotFoundException(String resourceName, Object id) {
        super(String.format("%s non trovato con id %s", resourceName, id));
    }

}


### File: pharma-service/src/main/java/tassproject/pharmaservice/SecurityConfig.java
----------------------------------------
package tassproject.pharmaservice;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.reactive.EnableWebFluxSecurity;
import org.springframework.security.config.web.server.ServerHttpSecurity;
import org.springframework.security.web.server.SecurityWebFilterChain;
import org.springframework.security.oauth2.jwt.ReactiveJwtDecoder;
import org.springframework.security.oauth2.jwt.NimbusReactiveJwtDecoder;

import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.StandardCharsets;
import java.util.Base64;

@Configuration
@EnableWebFluxSecurity
public class SecurityConfig {

    @Bean
    public ReactiveJwtDecoder reactiveJwtDecoder(
            @Value("${jwt.secret}") String secretValue
    ) {
        byte[] keyBytes;
        try {
            keyBytes = Base64.getDecoder().decode(secretValue);
        } catch (IllegalArgumentException ex) {
            keyBytes = secretValue.getBytes(StandardCharsets.UTF_8);
        }
        SecretKey key = new SecretKeySpec(keyBytes, "HmacSHA256");
        return NimbusReactiveJwtDecoder.withSecretKey(key).build();
    }

    @Bean
    public SecurityWebFilterChain springSecurityFilterChain(
            ServerHttpSecurity http,
            ReactiveJwtDecoder jwtDecoder
    ) {
        http
                .authorizeExchange(exchanges -> exchanges
                        .pathMatchers("/actuator/health").permitAll()
                        .anyExchange().authenticated()
                )
                .oauth2ResourceServer(oauth2 -> oauth2
                        .jwt(jwt -> jwt.jwtDecoder(jwtDecoder))
                );
        return http.build();
    }
}


### File: pharma-service/src/main/resources/application.properties
----------------------------------------
spring.application.name=pharma-service
server.port=${SERVER_PORT:8080}

spring.datasource.url=${SPRING_DATASOURCE_URL:jdbc:postgresql://localhost:5432/mydatabase}
spring.datasource.username=${SPRING_DATASOURCE_USERNAME:myuser}
spring.datasource.password=${SPRING_DATASOURCE_PASSWORD:secret}
spring.datasource.driver-class-name=org.postgresql.Driver

spring.jpa.hibernate.ddl-auto=${SPRING_JPA_HIBERNATE_DDL_AUTO:update}
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.properties.hibernate.default_schema=notification_service

management.endpoints.web.exposure.include=health,info

# HikariCP (opzionale)
spring.datasource.hikari.maximum-pool-size=10
spring.datasource.hikari.minimum-idle=2
spring.datasource.hikari.idle-timeout=300000
spring.datasource.hikari.max-lifetime=600000

jwt.secret=${JWT_SECRET:my_jwt_secret}
jwt.expiration=${JWT_EXPIRATION_MS:3600000}

### File: pharma-service/src/main/resources/application.yml
----------------------------------------
server:
  port: 8080
spring:
  application:
    name: pharma-service
  datasource:
    url: jdbc:postgresql://localhost:5432/health
    username: ${DB_USER:myuser}
    password: ${DB_PASS:mypass}
  jpa:
    hibernate:
      ddl-auto: none
    properties:
      hibernate:
        format_sql: true
        dialect: org.hibernate.dialect.PostgreSQLDialect
logging:
  level:
    sql: debug

# Security (JWT)
jwt:
  issuer: health‑stack

### File: pharma-service/src/test/java/tassproject/pharmaservice/PharmaServiceApplicationTests.java
----------------------------------------
package tassproject.pharmaservice;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class PharmaServiceApplicationTests {

    @Test
    void contextLoads() {
    }

}


### File: pom.xml
----------------------------------------
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="
           http://maven.apache.org/POM/4.0.0
           https://maven.apache.org/xsd/maven-4.0.0.xsd">

    <modelVersion>4.0.0</modelVersion>

    <!-- 1) Estendiamo Spring Boot Starter Parent per pluginManagement -->
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.1.4</version>
        <relativePath/> <!-- non cercare pom locale -->
    </parent>

    <!-- 2) Coordinate del modulo aggregatore -->
    <groupId>tassproject.backend</groupId>
    <artifactId>backend</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <packaging>pom</packaging>

    <name>TAAS Backend Aggregator</name>
    <description>Aggregatore dei microservizi backend per TAAS</description>

    <!-- 3) Proprietà condivise -->
    <properties>
        <!-- Java & Spring versions -->
        <java.version>17</java.version>
        <spring-boot.version>3.1.4</spring-boot.version>
        <spring-cloud.version>2023.0.3</spring-cloud.version>

        <!-- Driver & utility libs -->
        <postgresql.version>42.6.0</postgresql.version>
        <lombok.version>1.18.38</lombok.version>
        <testcontainers.version>1.18.3</testcontainers.version>
    </properties>

    <!-- 4) Import dei BOM di Spring Boot e Spring Cloud + gestione versioni comuni -->
    <dependencyManagement>
        <dependencies>
            <!-- Spring Boot dependencies BOM -->
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-dependencies</artifactId>
                <version>${spring-boot.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
            <!-- Spring Cloud dependencies BOM -->
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>${spring-cloud.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>

            <!-- Versione gestita del driver PostgreSQL -->
            <dependency>
                <groupId>org.postgresql</groupId>
                <artifactId>postgresql</artifactId>
                <version>${postgresql.version}</version>
                <scope>runtime</scope>
            </dependency>

            <!-- Lombok (annotation processing) -->
            <dependency>
                <groupId>org.projectlombok</groupId>
                <artifactId>lombok</artifactId>
                <version>${lombok.version}</version>
            </dependency>

            <!-- Testcontainers -->
            <dependency>
                <groupId>org.testcontainers</groupId>
                <artifactId>testcontainers</artifactId>
                <version>${testcontainers.version}</version>
                <scope>test</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>

    <!-- 4b) Dipendenze comuni ereditate dai moduli -->
    <dependencies>
        <!-- Driver JDBC PostgreSQL disponibile a runtime -->
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>
    </dependencies>

    <!-- 5) Configurazione centralizzata dei plugin Maven -->
    <build>
        <pluginManagement>
            <plugins>
                <!-- Compiler plugin per Java 17 + lombok -->
                <plugin>
                    <groupId>org.apache.maven.plugins</groupId>
                    <artifactId>maven-compiler-plugin</artifactId>
                    <version>3.11.0</version>
                    <configuration>
                        <source>${java.version}</source>
                        <target>${java.version}</target>
                        <annotationProcessorPaths>
                            <path>
                                <groupId>org.projectlombok</groupId>
                                <artifactId>lombok</artifactId>
                                <version>${lombok.version}</version>
                            </path>
                        </annotationProcessorPaths>
                    </configuration>
                </plugin>

                <!-- Spring Boot Maven Plugin -->
                <plugin>
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-maven-plugin</artifactId>
                    <version>${spring-boot.version}</version>
                </plugin>
            </plugins>
        </pluginManagement>
    </build>

    <!-- 6) Moduli figli -->
    <modules>
        <module>api-gateway</module>
        <module>prescription-service</module>
        <module>pharma-service</module>
        <module>dispensation-service</module>
        <module>inventory-service</module>
        <module>notification-service</module>
        <module>auth-service</module>
    </modules>


</project>


### File: prescription-service/pom.xml
----------------------------------------
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
                             https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>tassproject.backend</groupId>
        <artifactId>backend</artifactId>
        <version>0.0.1-SNAPSHOT</version>
        <relativePath>../pom.xml</relativePath>
    </parent>

    <artifactId>prescription-service</artifactId>
    <packaging>jar</packaging>
    <name>prescription-service</name>

    <!-- 1️⃣ Proprietà generali -->
    <properties>
        <!-- forziamo UTF-8 su sorgenti, report e resources -->
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
        <java.version>17</java.version>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-oauth2-jose</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-amqp</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        <dependency>
            <groupId>org.flywaydb</groupId>
            <artifactId>flyway-core</artifactId>
        </dependency>
        <!-- Test e Testcontainers -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>testcontainers</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>junit-jupiter</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>postgresql</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-config</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-oauth2-resource-server</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-webflux</artifactId>
        </dependency>
    </dependencies>

    <build>
        <!-- Disabilitiamo il resource filtering -->
        <resources>
            <resource>
                <directory>src/main/resources</directory>
                <filtering>false</filtering>
            </resource>
        </resources>

        <plugins>
            <!-- Impostiamo l’encoding su UTF-8 anche nel Resources Plugin -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-resources-plugin</artifactId>
                <version>3.3.1</version>
                <configuration>
                    <encoding>UTF-8</encoding>
                </configuration>
            </plugin>

            <!-- Compiler Plugin (per sicurezza, Java 17) -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.11.0</version>
                <configuration>
                    <source>${java.version}</source>
                    <target>${java.version}</target>
                    <encoding>${project.build.sourceEncoding}</encoding>
                </configuration>
            </plugin>

            <!-- Spring Boot Maven Plugin -->
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>


### File: prescription-service/src/main/java/tassproject/prescriptionservice/AuthorizationService.java
----------------------------------------
package tassproject.prescriptionservice;

import jakarta.annotation.Nonnull;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationToken;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;
import tassproject.prescriptionservice.repository.PrescriptionRepository;

import java.util.UUID;

@Component
@Transactional(readOnly = true)
public class AuthorizationService {

    private final PrescriptionRepository prescriptions;

    public AuthorizationService(PrescriptionRepository prescriptions) {
        this.prescriptions = prescriptions;
    }

    /* ------------------------------------------------------------------
       Utilities
       ------------------------------------------------------------------ */
    private Authentication auth() {
        return org.springframework.security.core.context.SecurityContextHolder
                .getContext().getAuthentication();
    }

    private String role() {
        return auth().getAuthorities().stream()
                .map(GrantedAuthority::getAuthority).findFirst().orElse("");
    }

    private UUID userId() {
        var token = (JwtAuthenticationToken) auth();
        String id = token.getToken().getClaimAsString("citizen_id");
        if (id == null) throw new AccessDeniedException("Missing claim citizen_id");
        return UUID.fromString(id);
    }

    /* ------------------------------------------------------------------
       Checks
       ------------------------------------------------------------------ */

    /** Verifica che chi chiede dati del paziente ne abbia diritto. */
    public void assertCanAccessPatient(@Nonnull UUID patientId) {
        switch (role()) {
            case "ROLE_PATIENT" -> {
                if (!userId().equals(patientId))
                    deny("Puoi accedere solo alle tue informazioni.");
            }
            case "ROLE_DOCTOR" -> {
                if (!prescriptions.existsByDoctorIdAndPatientId(userId(), patientId))
                    deny("Non sei il medico di questo paziente.");
            }
            case "ROLE_PHARMACIST" -> deny("Un farmacista non può leggere dati clinici del paziente.");
            case "ROLE_ADMIN" -> { /* sempre permesso */ }
            default -> deny("Ruolo non riconosciuto.");
        }
    }

    /** Verifica che chi chiede dati del medico sia il medico stesso
     oppure un suo paziente. */
    public void assertCanAccessDoctor(@Nonnull UUID doctorId) {
        switch (role()) {
            case "ROLE_DOCTOR" -> {
                if (!userId().equals(doctorId)) deny("Non sei quel medico.");
            }
            case "ROLE_PATIENT" -> {
                if (!prescriptions.existsByDoctorIdAndPatientId(doctorId, userId()))
                    deny("Quel medico non ti ha mai in cura.");
            }
            case "ROLE_ADMIN" -> { }
            default -> deny("Accesso non consentito.");
        }
    }

    private void deny(String msg) {
        throw new AccessDeniedException(msg);
    }
}


### File: prescription-service/src/main/java/tassproject/prescriptionservice/CitizenClient.java
----------------------------------------
package tassproject.prescriptionservice;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import org.springframework.web.reactive.function.client.WebClient;
import tassproject.prescriptionservice.CitizenDTO;

import java.util.UUID;

/** REST‑client minimale verso anagrafica‑service. */
@Component
public class CitizenClient {

    private final WebClient web;

    public CitizenClient(
            @Value("${anagrafica-service.base-url:http://anagrafica-service:8080}")
            String baseUrl) {
        this.web = WebClient.builder().baseUrl(baseUrl).build();
    }

    public CitizenDTO findById(UUID id) {
        return web.get()
                .uri("/api/v1/citizens/{id}", id)
                .retrieve()
                .bodyToMono(CitizenDTO.class)
                .block();
    }
}

### File: prescription-service/src/main/java/tassproject/prescriptionservice/CitizenDTO.java
----------------------------------------
package tassproject.prescriptionservice;

import java.time.LocalDate;
import java.util.UUID;

/** DTO ri‑usabile inter‑service con i campi anagrafici essenziali. */
public record CitizenDTO(
        UUID id,
        String cf,
        String nome,
        String cognome,
        LocalDate dataNascita,
        String luogoNascita,
        String cittaResidenza) {
}

### File: prescription-service/src/main/java/tassproject/prescriptionservice/CreatePrescriptionRequest.java
----------------------------------------
package tassproject.prescriptionservice;

import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import java.util.List;
import java.util.UUID;

public record CreatePrescriptionRequest(
        @NotNull UUID doctorId,
        @NotNull UUID patientId,
        String therapyDuration,
        boolean exemption,
        @NotNull @Size(min = 1) List<PrescriptionItemDto> items
) {}


### File: prescription-service/src/main/java/tassproject/prescriptionservice/GlobalExceptionHandler.java
----------------------------------------
package tassproject.prescriptionservice;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;

@ControllerAdvice
public class GlobalExceptionHandler {
    @ExceptionHandler(Exception.class)
    public ResponseEntity<?> handleException(Exception ex) {
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(new ErrorDTO("Server error", ex.getMessage()));
    }

    record ErrorDTO(String error, String details) {}
}


### File: prescription-service/src/main/java/tassproject/prescriptionservice/Prescription.java
----------------------------------------
package tassproject.prescriptionservice;

import jakarta.persistence.*;
import java.time.OffsetDateTime;
import java.util.*;

@Entity
@Table(name = "prescriptions")
public class Prescription {

    @Id
    @Column(columnDefinition = "uuid")
    private UUID id;

    @Column(name = "doctor_id", nullable = false, columnDefinition = "uuid")
    private UUID doctorId;

    @Column(name = "patient_id", nullable = false, columnDefinition = "uuid")
    private UUID patientId;

    @Column(name = "issued_at", nullable = false)
    private OffsetDateTime issuedAt;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private Status status;

    @Column(name = "exemption", nullable = false)
    private boolean exemption; // true = esente ticket, false = non esente

    @Column(name = "therapy_duration")
    private String therapyDuration; // Es: "7 giorni" (mappato direttamente per semplicità)

    @OneToMany(
            mappedBy = "prescription",
            cascade = CascadeType.ALL,
            orphanRemoval = true,
            fetch = FetchType.LAZY
    )
    private List<PrescriptionItem> items = new ArrayList<>();

    // --- Enum Stato Ricetta ---
    public enum Status {
        OPEN,
        DISPENSED,
        COMPLETED,
        CANCELLED
    }

    // --- Costruttori ---
    protected Prescription() {} // richiesto da JPA

    public Prescription(UUID id, UUID doctorId, UUID patientId, OffsetDateTime issuedAt, boolean exemption, String therapyDuration, List<PrescriptionItem> items) {
        this.id = id;
        this.doctorId = doctorId;
        this.patientId = patientId;
        this.issuedAt = issuedAt;
        this.status = Status.OPEN;
        this.exemption = exemption;
        this.therapyDuration = therapyDuration;
        setItems(items); // associa gli items a questa prescription
    }

    // Factory per nuove prescrizioni
    public static Prescription create(UUID doctorId, UUID patientId, boolean exemption, String therapyDuration, List<PrescriptionItem> items) {
        return new Prescription(UUID.randomUUID(), doctorId, patientId, OffsetDateTime.now(), exemption, therapyDuration, items);
    }

    // --- Metodi dominio ---
    public boolean isOpen() {
        return status == Status.OPEN;
    }

    public boolean isCompleted() {
        return status == Status.COMPLETED;
    }

    public boolean isDispensed() {
        return status == Status.DISPENSED;
    }

    public boolean isCancelled() {
        return status == Status.CANCELLED;
    }

    public void markDispensed() {
        if (!isOpen()) throw new IllegalStateException("Prescription must be OPEN to be dispensed.");
        this.status = Status.DISPENSED;
    }

    public void markCompleted() {
        if (status != Status.DISPENSED) throw new IllegalStateException("Prescription must be DISPENSED to complete.");
        this.status = Status.COMPLETED;
    }

    public void cancel() {
        if (isCompleted()) throw new IllegalStateException("Cannot cancel a completed prescription.");
        this.status = Status.CANCELLED;
    }

    // --- Getter e Setter ---
    public UUID getId() { return id; }
    public UUID getDoctorId() { return doctorId; }
    public UUID getPatientId() { return patientId; }
    public OffsetDateTime getIssuedAt() { return issuedAt; }
    public Status getStatus() { return status; }
    public boolean isExemption() { return exemption; }
    public String getTherapyDuration() { return therapyDuration; }
    public List<PrescriptionItem> getItems() { return items; }

    public void setItems(List<PrescriptionItem> items) {
        this.items.clear();
        if (items != null) {
            for (PrescriptionItem item : items) {
                item.setPrescription(this); // imposta il back-reference
                this.items.add(item);
            }
        }
    }

    // Opzionale: aggiungi utility per frontend
    public String getEsenzioneAsString() {
        return exemption ? "Si" : "No";
    }
}


### File: prescription-service/src/main/java/tassproject/prescriptionservice/PrescriptionApplicationService.java
----------------------------------------
package tassproject.prescriptionservice;

import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import tassproject.prescriptionservice.repository.PrescriptionItemRepository;
import tassproject.prescriptionservice.repository.PrescriptionRepository;

import java.util.List;
import java.util.UUID;

@Service
@Transactional
public class PrescriptionApplicationService {

    private final PrescriptionRepository repo;
    private final PrescriptionItemRepository items;
    private final RabbitTemplate rabbitTemplate;

    public PrescriptionApplicationService(PrescriptionRepository repo,
                                          PrescriptionItemRepository items,
                                          RabbitTemplate rabbitTemplate) {
        this.repo           = repo;
        this.items          = items;
        this.rabbitTemplate = rabbitTemplate;
    }

    /* ------------------------------ CREA ------------------------------ */
    public PrescriptionResponse create(CreatePrescriptionRequest req) {
        List<PrescriptionItem> itemEntities = req.items().stream()
                .map(dto -> new PrescriptionItem(
                        dto.drugId(),
                        dto.activeIngredientId(),
                        dto.activeIngredient(),
                        dto.dosage(),
                        dto.quantity()))
                .toList();

        Prescription entity = Prescription.create(
                req.doctorId(),
                req.patientId(),
                req.exemption(),
                req.therapyDuration(),
                itemEntities);

        entity = repo.save(entity);
        rabbitTemplate.convertAndSend("prescription.events", "PrescriptionCreated", entity.getId());
        return PrescriptionResponse.from(entity);
    }

    /* ------------------------------ QUERY BASE ------------------------ */
    @Transactional(readOnly = true)
    public PrescriptionResponse findById(UUID id) {
        return repo.findById(id).map(PrescriptionResponse::from).orElseThrow();
    }

    @Transactional(readOnly = true)
    public List<PrescriptionResponse> findActiveByPatientId(UUID patientId) {
        return repo.findAll().stream()
                .filter(p -> p.getPatientId().equals(patientId))
                .filter(p -> p.getStatus() == Prescription.Status.OPEN
                        || p.getStatus() == Prescription.Status.DISPENSED)
                .map(PrescriptionResponse::from)
                .toList();
    }

    /* ------------------------------ UPDATE STATO ---------------------- */
    public PrescriptionResponse updateStatus(UUID id, Prescription.Status newStatus) {
        Prescription entity = repo.findById(id).orElseThrow();
        switch (newStatus) {
            case DISPENSED  -> entity.markDispensed();
            case COMPLETED  -> entity.markCompleted();
            case CANCELLED  -> entity.cancel();
            default -> throw new IllegalStateException("Unsupported status transition");
        }
        repo.save(entity);
        rabbitTemplate.convertAndSend("prescription.events","PrescriptionStatusChanged", entity.getId());
        return PrescriptionResponse.from(entity);
    }

    /* ------------------------------ NUOVE QUERY ----------------------- */

    /* 1) Pazienti di un medico */
    @Transactional(readOnly = true)
    public List<UUID> getPatientsByDoctor(UUID doctorId) {
        return repo.findDistinctPatientIdsByDoctorId(doctorId);
    }

    /* 1‑bis) Medici di un paziente */
    @Transactional(readOnly = true)
    public List<UUID> getDoctorsByPatient(UUID patientId) {
        return repo.findDistinctDoctorIdsByPatientId(patientId);
    }

    /* 3) Tutte le prescrizioni di un medico */
    @Transactional(readOnly = true)
    public List<PrescriptionResponse> findByDoctor(UUID doctorId) {
        return repo.findByDoctorId(doctorId).stream()
                .map(PrescriptionResponse::from)
                .toList();
    }

    /* 6) Farmaci acquistati (erogati) da un paziente */
    @Transactional(readOnly = true)
    public List<UUID> getDrugIdsByPatient(UUID patientId) {
        return items.findDistinctDrugIdsByPatientId(patientId);
    }
}


### File: prescription-service/src/main/java/tassproject/prescriptionservice/PrescriptionController.java
----------------------------------------
package tassproject.prescriptionservice;

import jakarta.validation.Valid;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.*;
import tassproject.prescriptionservice.CitizenDTO;
import tassproject.prescriptionservice.CitizenClient;

import java.util.*;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/v1")
public class PrescriptionController {

    private final PrescriptionApplicationService service;
    private final AuthorizationService            authz;
    private final CitizenClient                   citizens;   // 🆕

    public PrescriptionController(PrescriptionApplicationService service,
                                  AuthorizationService authz,
                                  CitizenClient citizens) {   // 🆕
        this.service  = service;
        this.authz    = authz;
        this.citizens = citizens;
    }

    /* ------------------------------ CRUD ESISTENTI -------------------- */
    @PostMapping("/prescriptions")
    @ResponseStatus(HttpStatus.CREATED)
    public PrescriptionResponse create(@Valid @RequestBody CreatePrescriptionRequest request) {
        authz.assertCanAccessDoctor(request.doctorId());
        authz.assertCanAccessPatient(request.patientId());
        return service.create(request);
    }

    @GetMapping("/prescriptions/{id}")
    public PrescriptionResponse findById(@PathVariable UUID id) {
        var resp = service.findById(id);
        authz.assertCanAccessDoctor(resp.doctorId());
        authz.assertCanAccessPatient(resp.patientId());
        return resp;
    }

    @GetMapping("/patients/{patientId}/prescriptions/active")
    public List<PrescriptionResponse> findActive(@PathVariable UUID patientId) {
        authz.assertCanAccessPatient(patientId);
        return service.findActiveByPatientId(patientId);
    }

    @PutMapping("/prescriptions/{id}/status")
    public PrescriptionResponse updateStatus(@PathVariable UUID id,
                                             @Valid @RequestBody UpdatePrescriptionStatusRequest body) {
        var resp = service.findById(id);
        authz.assertCanAccessDoctor(resp.doctorId());
        return service.updateStatus(id, body.newStatus());
    }

    /* ------------------------------ QUERY UUID ----------------------- */
    @GetMapping("/doctors/{doctorId}/patients")
    public List<UUID> patientsOfDoctor(@PathVariable UUID doctorId) {
        authz.assertCanAccessDoctor(doctorId);
        return service.getPatientsByDoctor(doctorId);
    }

    @GetMapping("/patients/{patientId}/doctors")
    public List<UUID> doctorsOfPatient(@PathVariable UUID patientId) {
        authz.assertCanAccessPatient(patientId);
        return service.getDoctorsByPatient(patientId);
    }

    @GetMapping("/doctors/{doctorId}/prescriptions")
    public List<PrescriptionResponse> prescriptionsByDoctor(@PathVariable UUID doctorId) {
        authz.assertCanAccessDoctor(doctorId);
        return service.findByDoctor(doctorId);
    }

    @GetMapping("/patients/{patientId}/drugs")
    public List<UUID> drugsByPatient(@PathVariable UUID patientId) {
        authz.assertCanAccessPatient(patientId);
        return service.getDrugIdsByPatient(patientId);
    }

    /* ----------------------- NUOVO: DETTAGLI PAZIENTI ---------------- */
    @GetMapping("/doctors/{doctorId}/patients/details")
    public List<CitizenDTO> patientDetails(@PathVariable UUID doctorId) {
        authz.assertCanAccessDoctor(doctorId);
        return service.getPatientsByDoctor(doctorId).stream()
                .map(citizens::findById)
                .filter(Objects::nonNull)
                .collect(Collectors.toList());
    }
}

### File: prescription-service/src/main/java/tassproject/prescriptionservice/PrescriptionItem.java
----------------------------------------
package tassproject.prescriptionservice;

import jakarta.persistence.*;
import java.util.UUID;

@Entity
@Table(name = "prescription_items")
public class PrescriptionItem {

    @Id
    @Column(columnDefinition = "uuid")
    private UUID id;

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "prescription_id", nullable = false, columnDefinition = "uuid")
    private Prescription prescription;

    @Column(name = "drug_id", nullable = false, columnDefinition = "uuid")
    private UUID drugId;

    @Column(name = "active_ingredient_id", nullable = false, columnDefinition = "uuid")
    private UUID activeIngredientId;

    @Column(name = "active_ingredient", nullable = false)
    private String activeIngredient;

    @Column(nullable = false)
    private String dosage;

    @Column(nullable = false)
    private int quantity;

    protected PrescriptionItem() {
        // per JPA
    }

    public PrescriptionItem(UUID drugId,
                            UUID activeIngredientId,
                            String activeIngredient,
                            String dosage,
                            int quantity) {
        this.id = UUID.randomUUID();
        this.drugId = drugId;
        this.activeIngredientId = activeIngredientId;
        this.activeIngredient = activeIngredient;
        this.dosage = dosage;
        this.quantity = quantity;
    }

    public UUID getId() {
        return id;
    }

    public Prescription getPrescription() {
        return prescription;
    }

    public void setPrescription(Prescription prescription) {
        this.prescription = prescription;
    }

    public UUID getDrugId() {
        return drugId;
    }

    public void setDrugId(UUID drugId) {
        this.drugId = drugId;
    }

    public UUID getActiveIngredientId() {
        return activeIngredientId;
    }

    public void setActiveIngredientId(UUID activeIngredientId) {
        this.activeIngredientId = activeIngredientId;
    }

    public String getActiveIngredient() {
        return activeIngredient;
    }

    public void setActiveIngredient(String activeIngredient) {
        this.activeIngredient = activeIngredient;
    }

    public String getDosage() {
        return dosage;
    }

    public void setDosage(String dosage) {
        this.dosage = dosage;
    }

    public int getQuantity() {
        return quantity;
    }

    public void setQuantity(int quantity) {
        this.quantity = quantity;
    }

    public String getDescrizionePrincipioAttivo() {
        return activeIngredient + " " + dosage;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof PrescriptionItem)) return false;
        PrescriptionItem that = (PrescriptionItem) o;
        return id.equals(that.id);
    }

    @Override
    public int hashCode() {
        return id.hashCode();
    }
}


### File: prescription-service/src/main/java/tassproject/prescriptionservice/PrescriptionItemDto.java
----------------------------------------
package tassproject.prescriptionservice;

import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import java.util.UUID;

public record PrescriptionItemDto(
        @NotNull UUID drugId,
        @NotNull UUID activeIngredientId,
        @NotBlank String activeIngredient,
        @NotBlank String dosage,
        @Min(1) int quantity
) {}


### File: prescription-service/src/main/java/tassproject/prescriptionservice/PrescriptionItemRepository.java
----------------------------------------
package tassproject.prescriptionservice.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import tassproject.prescriptionservice.PrescriptionItem;

import java.util.List;
import java.util.UUID;

public interface PrescriptionItemRepository extends JpaRepository<PrescriptionItem, UUID> {

    /* farmaci (distinct) acquistati da un paziente */
    @Query("""
            select distinct i.drugId
            from PrescriptionItem i
            where i.prescription.patientId = :patientId
          """)
    List<UUID> findDistinctDrugIdsByPatientId(@Param("patientId") UUID patientId);
}


### File: prescription-service/src/main/java/tassproject/prescriptionservice/PrescriptionRepository.java
----------------------------------------
package tassproject.prescriptionservice.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import tassproject.prescriptionservice.Prescription;

import java.util.List;
import java.util.UUID;

public interface PrescriptionRepository extends JpaRepository<Prescription, UUID> {

    /* ------------- QUERY GIÀ PRESENTI ------------- */

    List<Prescription> findByDoctorId(UUID doctorId);

    @Query("select distinct p.patientId from Prescription p where p.doctorId = :doctorId")
    List<UUID> findDistinctPatientIdsByDoctorId(@Param("doctorId") UUID doctorId);

    @Query("select distinct p.doctorId from Prescription p where p.patientId = :patientId")
    List<UUID> findDistinctDoctorIdsByPatientId(@Param("patientId") UUID patientId);

    /* ------------- NUOVA UTILITY PER SECURITY ----- */

    boolean existsByDoctorIdAndPatientId(UUID doctorId, UUID patientId);
}


### File: prescription-service/src/main/java/tassproject/prescriptionservice/PrescriptionResponse.java
----------------------------------------
package tassproject.prescriptionservice;

import java.time.OffsetDateTime;
import java.util.List;
import java.util.UUID;

public record PrescriptionResponse(
        UUID id,
        UUID doctorId,
        UUID patientId,
        OffsetDateTime issuedAt,
        Prescription.Status status,
        boolean exemption,
        String therapyDuration,
        List<PrescriptionItemDto> items
) {
    public static PrescriptionResponse from(Prescription p) {
        return new PrescriptionResponse(
                p.getId(),
                p.getDoctorId(),
                p.getPatientId(),
                p.getIssuedAt(),
                p.getStatus(),
                p.isExemption(),
                p.getTherapyDuration(),
                p.getItems().stream()
                        .map(it -> new PrescriptionItemDto(
                                it.getDrugId(),
                                it.getActiveIngredientId(),
                                it.getActiveIngredient(),
                                it.getDosage(),
                                it.getQuantity()))
                        .toList()
        );
    }
}


### File: prescription-service/src/main/java/tassproject/prescriptionservice/PrescriptionServiceApplication.java
----------------------------------------
package tassproject.prescriptionservice;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class PrescriptionServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(PrescriptionServiceApplication.class, args);
    }

}


### File: prescription-service/src/main/java/tassproject/prescriptionservice/RabbitConfig.java
----------------------------------------
package tassproject.prescriptionservice;

import org.springframework.amqp.core.Binding;
import org.springframework.amqp.core.BindingBuilder;
import org.springframework.amqp.core.Exchange;
import org.springframework.amqp.core.ExchangeBuilder;
import org.springframework.amqp.core.Queue;
import org.springframework.amqp.core.QueueBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class RabbitConfig {

    @Bean
    public Exchange prescriptionExchange() {
        return ExchangeBuilder
                .topicExchange("prescription.events")
                .durable(true)
                .build();
    }

    @Bean
    public Queue prescriptionQueue() {
        return QueueBuilder
                .durable("prescription.queue")
                .build();
    }

    @Bean
    public Binding bindPrescriptionEvents(Queue prescriptionQueue, Exchange prescriptionExchange) {
        return BindingBuilder
                .bind(prescriptionQueue)
                .to(prescriptionExchange)
                .with("#")
                .noargs();
    }
}


### File: prescription-service/src/main/java/tassproject/prescriptionservice/SecurityConfig.java
----------------------------------------
package tassproject.prescriptionservice;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.Customizer;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.core.authority.mapping.SimpleAuthorityMapper;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.oauth2.jwt.NimbusJwtDecoder;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter;
import org.springframework.security.oauth2.server.resource.authentication.JwtGrantedAuthoritiesConverter;
import org.springframework.security.web.SecurityFilterChain;

import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.StandardCharsets;
import java.util.Base64;

@Configuration
@EnableMethodSecurity
public class SecurityConfig {

    /** Converte il claim “role” del JWT in autorità Spring Security ROLE_… */
    private JwtAuthenticationConverter jwtAuthenticationConverter() {
        JwtGrantedAuthoritiesConverter converter = new JwtGrantedAuthoritiesConverter();
        converter.setAuthorityPrefix("ROLE_");
        converter.setAuthoritiesClaimName("role");

        JwtAuthenticationConverter jwtConv = new JwtAuthenticationConverter();
        jwtConv.setJwtGrantedAuthoritiesConverter(converter);
        return jwtConv;
    }

    @Bean
    SecurityFilterChain apiSecurity(HttpSecurity http) throws Exception {
        http
                .csrf(csrf -> csrf.disable())
                .sessionManagement(sm -> sm.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .authorizeHttpRequests(reg -> reg
                        .requestMatchers("/actuator/**", "/v3/api-docs/**", "/swagger-ui/**").permitAll()
                        .anyRequest().authenticated()
                )
                .oauth2ResourceServer(oauth -> oauth
                        .jwt(jwt -> jwt.jwtAuthenticationConverter(jwtAuthenticationConverter()))
                )
                .httpBasic(Customizer.withDefaults());

        return http.build();
    }

    /**
     * Definisce il bean JwtDecoder per firmare/verificare token HMAC‑SHA256
     * usando la chiave fornita tramite property/env var “jwt.secret”.
     */
    @Bean
    public JwtDecoder jwtDecoder(@Value("${jwt.secret:my_jwt_secret}") String secret) {
        byte[] keyBytes;
        try {
            keyBytes = Base64.getDecoder().decode(secret);
        } catch (IllegalArgumentException ex) {
            keyBytes = secret.getBytes(StandardCharsets.UTF_8);
        }
        SecretKey key = new SecretKeySpec(keyBytes, "HmacSHA256");
        return NimbusJwtDecoder.withSecretKey(key).build();
    }
}


### File: prescription-service/src/main/java/tassproject/prescriptionservice/UpdatePrescriptionStatusRequest.java
----------------------------------------
package tassproject.prescriptionservice;

import jakarta.validation.constraints.NotNull;
import tassproject.prescriptionservice.Prescription;

public record UpdatePrescriptionStatusRequest(@NotNull Prescription.Status newStatus) {}

### File: prescription-service/src/main/resources/application.properties
----------------------------------------
<<ERROR reading file: 'utf-8' codec can't decode byte 0xe0 in position 393: invalid continuation byte>>


### File: prescription-service/src/main/resources/db/migration/V1__drop_foreign_keys.sql
----------------------------------------
-- Rimuove (se esiste) il vincolo che blocca l'inserimento
ALTER TABLE IF EXISTS prescription_service.prescriptions
    DROP CONSTRAINT IF EXISTS prescriptions_doctor_id_fkey;


### File: prescription-service/src/test/java/tassproject/prescriptionservice/PrescriptionRepositoryIT.java
----------------------------------------
package tassproject.prescriptionservice;

import org.junit.jupiter.api.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;
import org.springframework.test.context.DynamicPropertyRegistry;
import org.springframework.test.context.DynamicPropertySource;
import org.testcontainers.containers.PostgreSQLContainer;
import org.testcontainers.junit.jupiter.Container;
import org.testcontainers.junit.jupiter.Testcontainers;
import tassproject.prescriptionservice.repository.PrescriptionRepository;
import tassproject.prescriptionservice.repository.PrescriptionItemRepository;

import java.time.OffsetDateTime;
import java.util.List;
import java.util.UUID;

@Testcontainers
@DataJpaTest
class PrescriptionRepositoryIT {

    @Container
    static PostgreSQLContainer<?> postgres =
            new PostgreSQLContainer<>("postgres:16-alpine")
                    .withDatabaseName("db")
                    .withUsername("user")
                    .withPassword("pwd");

    @DynamicPropertySource
    static void overrideProps(DynamicPropertyRegistry r) {
        r.add("spring.datasource.url", postgres::getJdbcUrl);
        r.add("spring.datasource.username", postgres::getUsername);
        r.add("spring.datasource.password", postgres::getPassword);
    }

    @Autowired
    PrescriptionRepository prescriptions;

    @Autowired
    PrescriptionItemRepository items;

    @Test
    void crudEndToEnd() {
        // --- create ---
        UUID drugId = UUID.randomUUID();
        UUID activeIngredientId = UUID.randomUUID();
        String activeIngredient = "Paracetamolo";
        String dosage = "500mg";
        int quantity = 2;
        var item = new PrescriptionItem(
                drugId,
                activeIngredientId,
                activeIngredient,
                dosage,
                quantity
        );
        var presc = Prescription.create(
                UUID.randomUUID(), UUID.randomUUID(), false,
                "7 giorni", List.of(item));
        presc = prescriptions.save(presc);

        Assertions.assertNotNull(presc.getId());
        Assertions.assertEquals(1, presc.getItems().size());

        // --- read ---
        var found = prescriptions.findById(presc.getId()).orElseThrow();
        Assertions.assertEquals(presc.getDoctorId(), found.getDoctorId());

        // --- update ---
        found.markDispensed();
        prescriptions.save(found);
        Assertions.assertTrue(prescriptions.findById(found.getId()).orElseThrow().isDispensed());

        // --- delete (cascata su items) ---
        prescriptions.delete(found);
        Assertions.assertTrue(prescriptions.findAll().isEmpty());
        Assertions.assertTrue(items.findAll().isEmpty());
    }
}


### File: prescription-service/src/test/java/tassproject/prescriptionservice/PrescriptionServiceApplicationTests.java
----------------------------------------
package tassproject.prescriptionservice;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class PrescriptionServiceApplicationTests {

    @Test
    void contextLoads() {
    }

}


### File: src/main/java/tassproject/backend/BackendApplication.java
----------------------------------------
package tassproject.backend;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class BackendApplication {

    public static void main(String[] args) {
        SpringApplication.run(BackendApplication.class, args);
    }

}


### File: src/main/resources/application.properties
----------------------------------------
spring.application.name=dispensation-service   # cambia il nome
server.port=${SERVER_PORT:8080}               # fallback 8080, sovrascrivi in compose

spring.datasource.url=${SPRING_DATASOURCE_URL:jdbc:postgresql://localhost:5432/mydatabase}
spring.datasource.username=${SPRING_DATASOURCE_USERNAME:myuser}
spring.datasource.password=${SPRING_DATASOURCE_PASSWORD:secret}
spring.datasource.driver-class-name=org.postgresql.Driver

spring.jpa.hibernate.ddl-auto=${SPRING_JPA_HIBERNATE_DDL_AUTO:update}
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect

# esponi via HTTP gli endpoint health e info
management.endpoints.web.exposure.include=health,info


# HikariCP (opzionale)
spring.datasource.hikari.maximum-pool-size=10
spring.datasource.hikari.minimum-idle=2
spring.datasource.hikari.idle-timeout=300000
spring.datasource.hikari.max-lifetime=600000


### File: src/test/java/tassproject/backend/BackendApplicationTests.java
----------------------------------------
package tassproject.backend;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class BackendApplicationTests {

    @Test
    void contextLoads() {
    }

}


