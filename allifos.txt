### File: api-gateway/pom.xml
----------------------------------------
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
                             https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>tassproject.backend</groupId>
        <artifactId>backend</artifactId>
        <version>0.0.1-SNAPSHOT</version>
        <relativePath>../pom.xml</relativePath>
    </parent>

    <artifactId>api-gateway</artifactId>
    <packaging>jar</packaging>
    <name>api-gateway</name>

    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-gateway</artifactId>
        </dependency>

        <!-- üîê sicurezza & JWT resource-server -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>


### File: api-gateway/src/main/java/tassproject/apigateway/ApiGatewayApplication.java
----------------------------------------
package tassproject.apigateway;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration;

@SpringBootApplication(
        exclude = SecurityAutoConfiguration.class
)
public class ApiGatewayApplication {
    public static void main(String[] args) {
        SpringApplication.run(ApiGatewayApplication.class, args);
    }
}


### File: api-gateway/src/main/java/tassproject/apigateway/GlobalCorsConfig.java
----------------------------------------
package tassproject.apigateway;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.reactive.CorsWebFilter;
import org.springframework.web.cors.reactive.UrlBasedCorsConfigurationSource;

import java.util.List;

@Configuration
public class GlobalCorsConfig {

    @Bean
    public CorsWebFilter corsWebFilter() {
        CorsConfiguration cfg = new CorsConfiguration();
        cfg.setAllowedOrigins(List.of(
                "http://localhost:3000",
                "http://localhost:5173"
        ));
        cfg.setAllowedMethods(List.of("*"));
        cfg.setAllowedHeaders(List.of("*"));
        cfg.setAllowCredentials(true);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", cfg);

        return new CorsWebFilter(source);
    }
}


### File: api-gateway/src/main/java/tassproject/apigateway/JwtCookieAuthWebFilter.java
----------------------------------------
package tassproject.apigateway;

import org.springframework.core.Ordered;
import org.springframework.core.annotation.Order;
import org.springframework.http.HttpHeaders;
import org.springframework.http.server.reactive.ServerHttpRequest;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;
import org.springframework.web.server.WebFilter;
import org.springframework.web.server.WebFilterChain;
import reactor.core.publisher.Mono;

/**
 * Questo filtro intercetta la richiesta:
 * - Se manca l'header Authorization ma esiste il cookie access_token, aggiunge l'header.
 */
@Component
@Order(Ordered.HIGHEST_PRECEDENCE)
public class JwtCookieAuthWebFilter implements WebFilter {

    private static final String COOKIE_NAME = "access_token";

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, WebFilterChain chain) {
        String authHeader = exchange.getRequest().getHeaders().getFirst(HttpHeaders.AUTHORIZATION);

        // Se gi√† presente Authorization, passa avanti
        if (authHeader != null && !authHeader.isBlank()) {
            return chain.filter(exchange);
        }

        // Altrimenti cerca il cookie
        return Mono.defer(() -> {
            var cookie = exchange.getRequest().getCookies().getFirst(COOKIE_NAME);
            if (cookie != null && cookie.getValue() != null && !cookie.getValue().isBlank()) {
                // Crea una nuova request con l'header Authorization: Bearer <cookie_value>
                ServerHttpRequest mutatedRequest = exchange.getRequest().mutate()
                        .header(HttpHeaders.AUTHORIZATION, "Bearer " + cookie.getValue())
                        .build();
                ServerWebExchange mutatedExchange = exchange.mutate().request(mutatedRequest).build();
                return chain.filter(mutatedExchange);
            }
            // Nessun JWT in header o cookie ‚Üí passa avanti senza mutare nulla (scatta la security dopo)
            return chain.filter(exchange);
        });
    }
}


### File: api-gateway/src/main/java/tassproject/apigateway/SecurityConfig.java
----------------------------------------
package tassproject.apigateway;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.reactive.EnableWebFluxSecurity;
import org.springframework.security.config.web.server.ServerHttpSecurity;
import org.springframework.security.oauth2.jwt.NimbusReactiveJwtDecoder;
import org.springframework.security.oauth2.jwt.ReactiveJwtDecoder;
import org.springframework.security.web.server.SecurityWebFilterChain;

import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.StandardCharsets;
import java.util.Base64;

@Configuration
@EnableWebFluxSecurity
public class SecurityConfig {

    @Bean
    public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
        http
                .csrf(ServerHttpSecurity.CsrfSpec::disable)
                .authorizeExchange(ex -> ex
                        .pathMatchers("/oauth2/**", "/login/**").permitAll()
                        .pathMatchers("/api/v1/auth/**", "/actuator/**").permitAll()
                        .anyExchange().authenticated()
                )
                .oauth2ResourceServer(oauth2 -> oauth2.jwt());

        return http.build();
    }

    /**
     * Usa la chiave fornita tramite property /¬†env¬†var¬†‚Äújwt.secret‚Äù.
     * Se la stringa √® Base‚Äë64 la decodifichiamo, altrimenti la
     * trattiamo come testo puro UTF‚Äë8.
     */
    @Bean
    public ReactiveJwtDecoder jwtDecoder(
            @Value("${jwt.secret:my_jwt_secret}") String secret) {

        byte[] keyBytes;
        try {
            keyBytes = Base64.getDecoder().decode(secret);
        } catch (IllegalArgumentException ex) {
            keyBytes = secret.getBytes(StandardCharsets.UTF_8);
        }

        SecretKey key = new SecretKeySpec(keyBytes, "HmacSHA256");
        return NimbusReactiveJwtDecoder.withSecretKey(key).build();
    }
}


### File: api-gateway/src/main/resources/application.properties
----------------------------------------
spring.application.name=api-gateway
server.port=${SERVER_PORT:8080}
logging.level.org.springframework.security=INFO
# (NO JDBC: questo servizio non usa database direttamente)
# (NO JPA)
# (NO HikariCP)

# Health endpoint
management.endpoints.web.exposure.include=health,info

# === JWT segreto condiviso con auth-service ===
jwt.secret=${JWT_SECRET:my_jwt_secret}



### File: api-gateway/src/main/resources/application.yml
----------------------------------------
server:
  port: ${SERVER_PORT:8080}

spring:
  application:
    name: api-gateway

  cloud:
    gateway:
      globalcors:
        corsConfigurations:
          "[/**]":
            allowedOrigins: "http://localhost:3000,http://localhost:5173"
            allowedMethods: "*"
            allowedHeaders: "*"
            allowCredentials: true

      routes:

        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ  OAUTH2 GOOGLE  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        # (1) richiesta iniziale /oauth2/authorization/google
        - id: oauth2-authorization
          uri: http://auth-service:8080      # dentro la rete Docker
          predicates:
            - Path=/oauth2/authorization/google
          filters:
            - PreserveHostHeader             # host esterno rimane ‚Äúlocalhost:8080‚Äù

        # (2) callback /login/oauth2/**
        - id: oauth2-callback
          uri: http://auth-service:8080
          predicates:
            - Path=/login/oauth2/**
          filters:
            - PreserveHostHeader

        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ  AUTH REST  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        - id: auth-service
          uri: http://auth-service:8080
          predicates:
            - Path=/api/v1/auth/**

        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ  PRESCRIPTION  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        - id: prescription-service
          uri: ${PRESCRIPTION_SERVICE_URL:http://prescription-service:8080}
          predicates:
            - Path=/api/v1/prescriptions/**,/api/v1/patients/{patientId}/prescriptions/**

        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ  DISPENSATION  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        - id: dispensation-service
          uri: ${DISPENSATION_SERVICE_URL:http://dispensation-service:8080}
          predicates:
            - Path=/api/v1/dispensations/**,/api/v1/prescriptions/*/dispensations/**

        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ  INVENTORY  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        - id: inventory-service
          uri: ${INVENTORY_SERVICE_URL:http://inventory-service:8080}
          predicates:
            - Path=/api/v1/inventory/**

        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ  NOTIFICATION  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        - id: notification-service
          uri: ${NOTIFICATION_SERVICE_URL:http://notification-service:8080}
          predicates:
            - Path=/api/v1/notifications/**

      default-filters:
        - DedupeResponseHeader=Access-Control-Allow-Origin


### File: api-gateway/src/test/java/tassproject/apigateway/ApiGatewayApplicationTests.java
----------------------------------------
package tassproject.apigateway;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest(
        classes = ApiGatewayApplication.class,
        properties = {
                "spring.cloud.compatibility-verifier.enabled=false"
        }
)
class ApiGatewayApplicationTests {

    @Test
    void contextLoads() {
    }
}


### File: auth-service/pom.xml
----------------------------------------
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
                             https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>tassproject.backend</groupId>
        <artifactId>backend</artifactId>
        <version>0.0.1-SNAPSHOT</version>
        <relativePath>../pom.xml</relativePath>
    </parent>

    <artifactId>auth-service</artifactId>
    <name>auth-service</name>
    <packaging>jar</packaging>

    <properties>
        <java.version>17</java.version>
        <jjwt.version>0.12.5</jjwt.version>
    </properties>

    <dependencies>
        <!-- Core -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-oauth2-client</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
        </dependency>
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>

        <!-- JWT -->
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-api</artifactId>
            <version>${jjwt.version}</version>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-impl</artifactId>
            <version>${jjwt.version}</version>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-jackson</artifactId>
            <version>${jjwt.version}</version>
            <scope>runtime</scope>
        </dependency>

        <!-- Annotation API per javax.annotation.PostConstruct -->
        <dependency>
            <groupId>javax.annotation</groupId>
            <artifactId>javax.annotation-api</artifactId>
            <version>1.3.2</version>
        </dependency>

        <!-- Validation & Lombok -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <scope>provided</scope>
        </dependency>

        <!-- Test -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>

    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>


### File: auth-service/src/main/java/tassproject/authservice/AuthController.java
----------------------------------------
package tassproject.authservice.controller;

import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.*;
import tassproject.authservice.*;
import tassproject.authservice.AuthService;

@RestController
@RequestMapping("/api/v1/auth")
@RequiredArgsConstructor
public class AuthController {

    private final AuthService auth;

    @PostMapping("/register")
    @ResponseStatus(HttpStatus.CREATED)
    public AuthResponse register(@Valid @RequestBody RegisterRequest body) {
        return auth.register(body);
    }

    @PostMapping("/login")
    public AuthResponse login(@Valid @RequestBody LoginRequest body) {
        return auth.login(body);
    }
}


### File: auth-service/src/main/java/tassproject/authservice/AuthResponse.java
----------------------------------------
package tassproject.authservice;

public record AuthResponse(String tokenType, String accessToken) {
    public static AuthResponse bearer(String jwt) {
        return new AuthResponse("Bearer", jwt);
    }
}


### File: auth-service/src/main/java/tassproject/authservice/AuthService.java
----------------------------------------
package tassproject.authservice;

import lombok.RequiredArgsConstructor;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import tassproject.authservice.repository.UserRepository;

@Service
@RequiredArgsConstructor
public class AuthService {

    private final UserRepository users;
    private final PasswordEncoder passwordEncoder;
    private final JwtUtil jwtUtil;

    /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ REGISTER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

    public AuthResponse register(RegisterRequest request) {
        String username = request.email().toLowerCase();

        if (users.findByUsername(username).isPresent()) {
            throw new IllegalArgumentException("Username gi√† in uso");
        }

        User user = new User(
                username,
                passwordEncoder.encode(request.password()),
                request.role()
        );

        users.save(user);

        String token = jwtUtil.generateToken(user);
        return new AuthResponse("Bearer", token);
    }

    /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ  LOGIN  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

    public AuthResponse login(LoginRequest request) {
        User user = users.findByUsername(request.email().toLowerCase())
                .orElseThrow(() -> new IllegalArgumentException("Credenziali non valide"));

        if (!passwordEncoder.matches(request.password(), user.getPassword())) {
            throw new IllegalArgumentException("Credenziali non valide");
        }

        String token = jwtUtil.generateToken(user);
        return new AuthResponse("Bearer", token);
    }
}


### File: auth-service/src/main/java/tassproject/authservice/AuthServiceApplication.java
----------------------------------------
package tassproject.authservice;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class AuthServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(AuthServiceApplication.class, args);
    }
}


### File: auth-service/src/main/java/tassproject/authservice/GlobalCorsConfig.java
----------------------------------------
package tassproject.authservice;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.filter.CorsFilter;

import java.util.List;

@Configuration
public class GlobalCorsConfig {

    @Bean
    public CorsFilter corsFilter() {
        CorsConfiguration cfg = new CorsConfiguration();
        cfg.setAllowedOrigins(List.of(
                "http://localhost:5173",
                "http://localhost:3000"
        ));
        cfg.setAllowedMethods(List.of("*"));
        cfg.setAllowedHeaders(List.of("*"));
        cfg.setAllowCredentials(true);

        var source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", cfg);

        return new CorsFilter(source);
    }
}


### File: auth-service/src/main/java/tassproject/authservice/GlobalExceptionHandler.java
----------------------------------------
package tassproject.authservice;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.http.HttpStatus;

import java.util.stream.Collectors;

@ControllerAdvice
public class GlobalExceptionHandler {

    public record ErrorResponse(String error, String message) {}

    // Validazione @Valid fallita ‚Üí 400 Bad Request
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleValidation(MethodArgumentNotValidException ex) {
        String details = ex.getBindingResult().getFieldErrors().stream()
                .map(fe -> fe.getField() + ": " + fe.getDefaultMessage())
                .collect(Collectors.joining("; "));
        return ResponseEntity
                .status(HttpStatus.BAD_REQUEST)
                .body(new ErrorResponse("Validation Failed", details));
    }

    // IllegalArgumentException dal business logic ‚Üí 400 Bad Request
    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<ErrorResponse> handleBadRequest(IllegalArgumentException ex) {
        return ResponseEntity
                .status(HttpStatus.BAD_REQUEST)
                .body(new ErrorResponse("Bad Request", ex.getMessage()));
    }

    // Fallback per qualsiasi altra eccezione ‚Üí 500 Internal Server Error
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleAll(Exception ex) {
        return ResponseEntity
                .status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(new ErrorResponse("Internal Server Error", ex.getMessage()));
    }
}


### File: auth-service/src/main/java/tassproject/authservice/JwtUtil.java
----------------------------------------
package tassproject.authservice;

import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.io.Decoders;
import io.jsonwebtoken.io.DecodingException;
import io.jsonwebtoken.security.Keys;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import javax.annotation.PostConstruct;
import javax.crypto.SecretKey;
import java.nio.charset.StandardCharsets;
import java.util.Date;

@Component
public class JwtUtil {

    @Value("${jwt.secret}")
    private String secretValue;

    @Value("${jwt.expiration}")
    private long jwtExpirationMs;

    private SecretKey key;

    @PostConstruct
    public void init() {
        byte[] keyBytes;
        try {
            keyBytes = Decoders.BASE64.decode(secretValue);
        } catch (IllegalArgumentException | DecodingException ex) {
            keyBytes = secretValue.getBytes(StandardCharsets.UTF_8);
        }

        if (keyBytes.length < 32) {
            throw new IllegalStateException(
                    "Il JWT_SECRET configurato √® troppo corto (" +
                            (keyBytes.length * 8) + " bit). " +
                            "Deve essere almeno 256 bit. Genera con: openssl rand -base64 32"
            );
        }

        this.key = Keys.hmacShaKeyFor(keyBytes);
    }

    public String generateToken(User user) {
        return Jwts.builder()
                .setSubject(user.getUsername())
                .setIssuedAt(new Date())
                .setExpiration(new Date(System.currentTimeMillis() + jwtExpirationMs))
                .signWith(key, SignatureAlgorithm.HS256)
                .compact();
    }

    public String getUsernameFromToken(String token) {
        return Jwts.parser()
                .verifyWith(key)
                .build()
                .parseSignedClaims(token)
                .getPayload()
                .getSubject();
    }

    public boolean validateToken(String token) {
        try {
            Jwts.parser().verifyWith(key).build().parseSignedClaims(token);
            return true;
        } catch (Exception ex) {
            return false;
        }
    }
}


### File: auth-service/src/main/java/tassproject/authservice/LoginRequest.java
----------------------------------------
package tassproject.authservice;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;

public record LoginRequest(
        @NotBlank @Email String email,
        @NotBlank String password) {}


### File: auth-service/src/main/java/tassproject/authservice/OAuth2LoginSuccessHandler.java
----------------------------------------
package tassproject.authservice;

import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.RequiredArgsConstructor;
import org.springframework.security.core.Authentication;
import org.springframework.security.oauth2.core.user.OAuth2User;
import org.springframework.security.web.authentication.AuthenticationSuccessHandler;
import org.springframework.stereotype.Component;
import tassproject.authservice.repository.UserRepository;

import jakarta.servlet.ServletException;
import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.Map;

@Component
@RequiredArgsConstructor
public class OAuth2LoginSuccessHandler implements AuthenticationSuccessHandler {

    private final UserRepository userRepository;
    private final JwtUtil jwtUtil;

    @Override
    public void onAuthenticationSuccess(HttpServletRequest request,
                                        HttpServletResponse response,
                                        Authentication authentication)
            throws IOException, ServletException {

        // 1) Estrai l‚ÄôOAuth2User e la sua email
        OAuth2User oAuth2User = (OAuth2User) authentication.getPrincipal();
        String email = oAuth2User.getAttribute("email");

        // 2) Se Google non ci fornisce l‚Äôemail, rimandiamo 401 con JSON di errore
        if (email == null) {
            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
            response.setContentType("application/json");
            new ObjectMapper().writeValue(response.getWriter(),
                    Map.of(
                            "error", "Unauthorized",
                            "message", "No email provided by Google"
                    )
            );
            return;
        }

        // 3) Trova o crea l‚Äôutente locale
        User user = userRepository.findByUsername(email.toLowerCase())
                .orElseGet(() -> {
                    User u = new User(
                            email.toLowerCase(),
                            "",            // password vuota perch√© non useremo il form-login
                            Role.PATIENT   // ruolo di default
                    );
                    return userRepository.save(u);
                });

        // 4) Genera il JWT
        String jwt = jwtUtil.generateToken(user);

        // 5) Imposta il JWT in un cookie HttpOnly
        Cookie jwtCookie = new Cookie("access_token", jwt);
        jwtCookie.setHttpOnly(true);
        jwtCookie.setSecure(request.isSecure());
        jwtCookie.setPath("/");
        jwtCookie.setMaxAge(60 * 60); // 1 ora
        // Se servisse cross-site:
        // jwtCookie.setSecure(true);
        // jwtCookie.setSameSite("None");
        response.addCookie(jwtCookie);

        // 6) Redirect diretto al frontend per la selezione del ruolo
        response.sendRedirect("http://localhost:3000/seleziona-ruolo");
    }
}


### File: auth-service/src/main/java/tassproject/authservice/OAuth2SecurityConfig.java
----------------------------------------
package tassproject.authservice;

import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.annotation.Order;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
@RequiredArgsConstructor
public class OAuth2SecurityConfig {

    private final OAuth2LoginSuccessHandler successHandler;
    private final RestAuthenticationEntryPoint restEntryPoint;
    private final RestAccessDeniedHandler restAccessDeniedHandler;

    @Bean
    @Order(1)
    public SecurityFilterChain oauth2LoginFilterChain(HttpSecurity http) throws Exception {
        http
                .securityMatcher(
                        "/oauth2/authorization/google",
                        "/login/oauth2/**",
                        "/api/v1/auth/**",
                        "/actuator/**"
                )
                .csrf(csrf -> csrf.disable())
                .authorizeHttpRequests(auth -> auth
                        .anyRequest().permitAll()
                )
                .exceptionHandling(ex -> ex
                        .authenticationEntryPoint(restEntryPoint)
                        .accessDeniedHandler(restAccessDeniedHandler)
                )
                .sessionManagement(sm -> sm.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .oauth2Login(oauth2 -> oauth2
                        .successHandler(successHandler)
                );
        return http.build();
    }
}


### File: auth-service/src/main/java/tassproject/authservice/RegisterRequest.java
----------------------------------------
package tassproject.authservice;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import tassproject.authservice.Role;

public record RegisterRequest(
        @NotBlank @Email String email,
        @NotBlank String password,
        @NotNull Role role) {}


### File: auth-service/src/main/java/tassproject/authservice/ResourceServerConfig.java
----------------------------------------
package tassproject.authservice;

import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.annotation.Order;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
@EnableWebSecurity
@RequiredArgsConstructor
public class ResourceServerConfig {

    private final JwtDecoder jwtDecoder;

    @Bean
    @Order(2)
    public SecurityFilterChain resourceServerFilterChain(HttpSecurity http) throws Exception {
        http
                .csrf(csrf -> csrf.disable())
                .authorizeHttpRequests(auth -> auth
                        .anyRequest().authenticated()
                )
                .sessionManagement(sm -> sm.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .oauth2ResourceServer(oauth2 -> oauth2
                        .jwt(jwt -> jwt.decoder(jwtDecoder))
                );
        return http.build();
    }
}


### File: auth-service/src/main/java/tassproject/authservice/RestAccessDeniedHandler.java
----------------------------------------
package tassproject.authservice;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.http.MediaType;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.web.access.AccessDeniedHandler;
import org.springframework.stereotype.Component;

import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import java.io.IOException;

@Component
public class RestAccessDeniedHandler implements AccessDeniedHandler {

    private final ObjectMapper mapper = new ObjectMapper();

    @Override
    public void handle(
            HttpServletRequest request,
            HttpServletResponse response,
            AccessDeniedException accessDeniedException
    ) throws IOException {
        response.setStatus(HttpServletResponse.SC_FORBIDDEN);
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        var error = new GlobalExceptionHandler.ErrorResponse(
                "Forbidden",
                accessDeniedException.getMessage()
        );
        mapper.writeValue(response.getOutputStream(), error);
    }
}


### File: auth-service/src/main/java/tassproject/authservice/RestAuthenticationEntryPoint.java
----------------------------------------
package tassproject.authservice;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.http.MediaType;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.stereotype.Component;

import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import java.io.IOException;

@Component
public class RestAuthenticationEntryPoint implements AuthenticationEntryPoint {

    private final ObjectMapper mapper = new ObjectMapper();

    @Override
    public void commence(
            HttpServletRequest request,
            HttpServletResponse response,
            AuthenticationException authException
    ) throws IOException {
        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        // usa lo stesso DTO ErrorResponse del GlobalExceptionHandler
        var error = new GlobalExceptionHandler.ErrorResponse(
                "Unauthorized",
                authException.getMessage()
        );
        mapper.writeValue(response.getOutputStream(), error);
    }
}


### File: auth-service/src/main/java/tassproject/authservice/Role.java
----------------------------------------
package tassproject.authservice;

public enum Role {
    PATIENT,
    MEDICO,
    FARMACISTA,
    SSN_ADMIN
}


### File: auth-service/src/main/java/tassproject/authservice/SecurityConfig.java
----------------------------------------
package tassproject.authservice;

import com.nimbusds.jose.jwk.source.ImmutableSecret;
import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.ProviderManager;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.Customizer;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.oauth2.jwt.JwtEncoder;
import org.springframework.security.oauth2.jwt.NimbusJwtDecoder;
import org.springframework.security.oauth2.jwt.NimbusJwtEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.access.AccessDeniedHandler;
import org.springframework.security.web.AuthenticationEntryPoint;
import tassproject.authservice.repository.UserRepository;

import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.StandardCharsets;

@Configuration
@EnableWebSecurity
@RequiredArgsConstructor
public class SecurityConfig {

    private final UserRepository users;
    private final RestAuthenticationEntryPoint restEntryPoint;
    private final RestAccessDeniedHandler restAccessDeniedHandler;
    private final OAuth2LoginSuccessHandler oAuth2LoginSuccessHandler;  // <‚Äî iniettato

    // -------- UserDetailsService --------
    @Bean
    public UserDetailsService userDetailsService() {
        return username -> users.findByUsername(username.toLowerCase())
                .map(user -> org.springframework.security.core.userdetails.User
                        .withUsername(user.getUsername())
                        .password(user.getPassword())
                        .roles(user.getRole().name())
                        .build())
                .orElseThrow(() ->
                        new UsernameNotFoundException("Utente non trovato: " + username));
    }

    // -------- Encoder / AuthenticationManager --------
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationManager authenticationManager(UserDetailsService uds) {
        DaoAuthenticationProvider provider = new DaoAuthenticationProvider();
        provider.setUserDetailsService(uds);
        provider.setPasswordEncoder(passwordEncoder());
        return new ProviderManager(provider);
    }

    // -------- JWT encoder/decoder --------
    @Bean
    public JwtEncoder jwtEncoder(@Value("${jwt.secret:my_jwt_secret}") String secret) {
        return new NimbusJwtEncoder(new ImmutableSecret<>(secret.getBytes(StandardCharsets.UTF_8)));
    }

    @Bean
    public JwtDecoder jwtDecoder(@Value("${jwt.secret:my_jwt_secret}") String secret) {
        return NimbusJwtDecoder
                .withSecretKey(new SecretKeySpec(secret.getBytes(StandardCharsets.UTF_8), "HmacSHA256"))
                .build();
    }

    // -------- Security filter chain --------
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
                .csrf(csrf -> csrf.disable())
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers("/api/v1/auth/**", "/actuator/**").permitAll()
                        .anyRequest().authenticated()
                )
                .exceptionHandling(ex -> ex
                        .authenticationEntryPoint(restEntryPoint)
                        .accessDeniedHandler(restAccessDeniedHandler)
                )
                .sessionManagement(sm -> sm.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .authenticationManager(authenticationManager(userDetailsService()))
                .oauth2Login(oauth2 -> oauth2
                        .successHandler(oAuth2LoginSuccessHandler)      // <‚Äî qui
                )
                .oauth2ResourceServer(oauth2 -> oauth2
                        .jwt(Customizer.withDefaults())
                );

        return http.build();
    }
}


### File: auth-service/src/main/java/tassproject/authservice/User.java
----------------------------------------
package tassproject.authservice;

import jakarta.persistence.*;

@Entity
@Table(name = "users")
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true)
    private String username;

    @Column(nullable = false)
    private String password;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private Role role;

    public User() {}

    public User(String username, String password, Role role) {
        this.username = username;
        this.password = password;
        this.role = role;
    }

    public Long getId() {
        return id;
    }

    public String getUsername() {
        return username;
    }

    public String getPassword() {
        return password;
    }

    public Role getRole() {
        return role;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public void setRole(Role role) {
        this.role = role;
    }
}


### File: auth-service/src/main/java/tassproject/authservice/UserRepository.java
----------------------------------------
package tassproject.authservice.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import tassproject.authservice.User;

import java.util.Optional;

public interface UserRepository extends JpaRepository<User, Long> {

    /* Cerca l‚Äôutente per username (e-mail normalizzata) */
    Optional<User> findByUsername(String username);
}


### File: auth-service/src/main/resources/application.properties
----------------------------------------
# ????????? Logging Spring Security ?????????
logging.level.org.springframework.security=INFO

# ????????? Spring Boot ?????????
spring.application.name=auth-service
server.port=${SERVER_PORT:8080}

# ????????? Datasource ?????????
spring.datasource.url=${SPRING_DATASOURCE_URL:jdbc:postgresql://localhost:5432/mydatabase}
spring.datasource.username=${SPRING_DATASOURCE_USERNAME:myuser}
spring.datasource.password=${SPRING_DATASOURCE_PASSWORD:secret}
spring.datasource.driver-class-name=org.postgresql.Driver

# ????????? JPA / Hibernate ?????????
spring.jpa.hibernate.ddl-auto=${SPRING_JPA_HIBERNATE_DDL_AUTO:update}
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.properties.hibernate.default_schema=auth_service

# ????????? JWT Settings ?????????
jwt.secret=${JWT_SECRET:U8mG8YkqzUjH9iMz4HfA3V6pEJxQ1r4z7NnYtX9aQ2M=}
jwt.expiration=${JWT_EXPIRATION_MS:3600000}

# ????????? OAuth2 Google Registration ?????????
spring.security.oauth2.client.registration.google.client-id=1052773766792-14leidinpkl862i67o4k62ck8iqtqjrn.apps.googleusercontent.com
spring.security.oauth2.client.registration.google.client-secret=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
spring.security.oauth2.client.registration.google.redirect-uri={baseUrl}/login/oauth2/code/{registrationId}
spring.security.oauth2.client.registration.google.scope=openid,profile,email

# ????????? OAuth2 Google Provider Endpoints ?????????
spring.security.oauth2.client.provider.google.authorization-uri=https://accounts.google.com/o/oauth2/auth
spring.security.oauth2.client.provider.google.token-uri=https://oauth2.googleapis.com/token
spring.security.oauth2.client.provider.google.user-info-uri=https://www.googleapis.com/oauth2/v3/userinfo
spring.security.oauth2.client.provider.google.user-name-attribute=sub

# ????????? Forward Headers & Actuator ?????????
server.forward-headers-strategy=native
management.endpoints.web.exposure.include=health,info


### File: auth-service/src/main/resources/application.yml
----------------------------------------
spring:
  cloud:
    gateway:
      globalcors:
        corsConfigurations:
          "[/**]":
            allowedOrigins: "http://localhost:5173,http://localhost:3000"
            allowedMethods: "*"
            allowedHeaders: "*"


### File: auth-service/src/test/java/tassproject/authservice/AuthServiceApplicationTests.java
----------------------------------------
package tassproject.authservice;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class AuthServiceApplicationTests {

    @Test
    void contextLoads() {
    }

}


### File: common/pom.xml
----------------------------------------
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
                             https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>tassproject.backend</groupId>
        <artifactId>backend</artifactId>
        <version>0.0.1-SNAPSHOT</version>
        <relativePath>../pom.xml</relativePath>
    </parent>

    <artifactId>common</artifactId>
    <packaging>jar</packaging>
    <name>common</name>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>jakarta.persistence</groupId>
            <artifactId>jakarta.persistence-api</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <!-- libreria: niente repackage -->
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration><skip>true</skip></configuration>
            </plugin>
        </plugins>
    </build>
</project>


### File: common/src/main/java/tassproject/common/CommonApplication.java
----------------------------------------
package tassproject.backend.common;

import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;
import org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration;

@SpringBootApplication(
        exclude = {
                DataSourceAutoConfiguration.class,
                HibernateJpaAutoConfiguration.class
        }
)
public class CommonApplication {
    // Questa classe serve solo per il test di context-loading in common
}


### File: common/src/main/resources/application.properties
----------------------------------------
# common module (library, no HTTP exposed)
spring.application.name=common


### File: common/src/test/java/tassproject/common/CommonApplicationTests.java
----------------------------------------
package tassproject.common;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;
import tassproject.backend.common.CommonApplication;

@SpringBootTest(classes = CommonApplication.class)
class CommonApplicationTests {
    @Test
    void contextLoads() {
    }
}


### File: dispensation-service/pom.xml
----------------------------------------
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="
           http://maven.apache.org/POM/4.0.0
           https://maven.apache.org/xsd/maven-4.0.0.xsd">

    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>tassproject.backend</groupId>
        <artifactId>backend</artifactId>
        <version>0.0.1-SNAPSHOT</version>
        <relativePath>../pom.xml</relativePath>
    </parent>

    <artifactId>dispensation-service</artifactId>
    <packaging>jar</packaging>
    <name>dispensation-service</name>

    <properties>
        <java.version>17</java.version>
    </properties>

    <dependencies>
        <!-- Core -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>tassproject.backend</groupId>
            <artifactId>common</artifactId>
            <version>${project.version}</version>
        </dependency>

        <!-- Testing -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <!-- Testcontainers core -->
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>testcontainers</artifactId>
            <version>1.18.3</version>
            <scope>test</scope>
        </dependency>
        <!-- Testcontainers PostgreSQL module -->
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>postgresql</artifactId>
            <version>1.18.3</version>
            <scope>test</scope>
        </dependency>
        <!-- JUnit Jupiter integration for Testcontainers -->
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>junit-jupiter</artifactId>
            <version>1.18.3</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.amqp</groupId>
            <artifactId>spring-rabbit</artifactId>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
        </dependency>
        <!-- Actuator per health-check -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>

    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

</project>


### File: dispensation-service/src/main/java/DispensationRepository.java
----------------------------------------
package tassproject.dispensationservice.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import tassproject.dispensationservice.Dispensation;

import java.util.UUID;

public interface DispensationRepository extends JpaRepository<Dispensation, UUID> {
}


### File: dispensation-service/src/main/java/tassproject/dispensationservice/CreateDispensationRequest.java
----------------------------------------
package tassproject.dispensationservice;

import jakarta.validation.constraints.NotNull;
import java.util.UUID;

public record CreateDispensationRequest(@NotNull UUID prescriptionId, @NotNull UUID dispensedBy) {}

### File: dispensation-service/src/main/java/tassproject/dispensationservice/Dispensation.java
----------------------------------------
package tassproject.dispensationservice;

import jakarta.persistence.*;
import java.time.OffsetDateTime;
import java.util.UUID;

@Entity
@Table(name = "dispensations")
public class Dispensation {

    @Id
    @Column(columnDefinition = "uuid")
    private UUID id;

    // Riferimento alla Prescription via UUID, non l‚Äôentit√† JPA di un altro microservizio
    @Column(name = "prescription_id", nullable = false, columnDefinition = "uuid")
    private UUID prescriptionId;

    @Column(name = "dispensed_at", nullable = false)
    private OffsetDateTime dispensedAt;

    @Column(name = "dispensed_by", nullable = false, columnDefinition = "uuid")
    private UUID dispensedBy;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private Status status;

    public enum Status {
        DONE,
        FAILED
    }

    public Dispensation() {}

    public Dispensation(UUID id, UUID prescriptionId, OffsetDateTime dispensedAt, UUID dispensedBy, Status status) {
        this.id = id;
        this.prescriptionId = prescriptionId;
        this.dispensedAt = dispensedAt;
        this.dispensedBy = dispensedBy;
        this.status = status;
    }

    public UUID getId() {
        return id;
    }

    public void setId(UUID id) {
        this.id = id;
    }

    public UUID getPrescriptionId() {
        return prescriptionId;
    }

    public void setPrescriptionId(UUID prescriptionId) {
        this.prescriptionId = prescriptionId;
    }

    public OffsetDateTime getDispensedAt() {
        return dispensedAt;
    }

    public void setDispensedAt(OffsetDateTime dispensedAt) {
        this.dispensedAt = dispensedAt;
    }

    public UUID getDispensedBy() {
        return dispensedBy;
    }

    public void setDispensedBy(UUID dispensedBy) {
        this.dispensedBy = dispensedBy;
    }

    public Status getStatus() {
        return status;
    }

    public void setStatus(Status status) {
        this.status = status;
    }
}


### File: dispensation-service/src/main/java/tassproject/dispensationservice/DispensationApplicationService.java
----------------------------------------
package tassproject.dispensationservice;

import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import tassproject.dispensationservice.repository.DispensationRepository;

import java.time.OffsetDateTime;
import java.util.List;
import java.util.UUID;

@Service
@Transactional
public class DispensationApplicationService {

    private final DispensationRepository repo;
    private final RabbitTemplate rabbitTemplate;

    @Autowired
    public DispensationApplicationService(DispensationRepository repo,
                                          RabbitTemplate rabbitTemplate) {
        this.repo = repo;
        this.rabbitTemplate = rabbitTemplate;
    }

    public DispensationResponse dispense(CreateDispensationRequest request) {
        var entity = new Dispensation(
                UUID.randomUUID(),
                request.prescriptionId(),
                OffsetDateTime.now(),
                request.dispensedBy(),
                Dispensation.Status.DONE
        );
        entity = repo.save(entity);
        rabbitTemplate.convertAndSend(
                "dispensation.events",
                "PrescriptionDispensed",
                entity.getPrescriptionId()
        );
        return DispensationResponse.from(entity);
    }

    @Transactional(readOnly = true)
    public List<DispensationResponse> listByPrescription(UUID prescriptionId) {
        return repo.findAll().stream()
                .filter(d -> d.getPrescriptionId().equals(prescriptionId))
                .map(DispensationResponse::from)
                .toList();
    }
}


### File: dispensation-service/src/main/java/tassproject/dispensationservice/DispensationController.java
----------------------------------------
package tassproject.dispensationservice;

import jakarta.validation.Valid;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.*;
import java.util.List;
import java.util.UUID;

@RestController
@RequestMapping("/api/v1")
public class DispensationController {

    private final DispensationApplicationService service;

    // Costruttore esplicito con service iniettato da Spring
    public DispensationController(DispensationApplicationService service) {
        this.service = service;
    }

    @PostMapping("/dispensations")
    @ResponseStatus(HttpStatus.CREATED)
    public DispensationResponse dispense(@Valid @RequestBody CreateDispensationRequest request) {
        return service.dispense(request);
    }

    @GetMapping("/prescriptions/{prescriptionId}/dispensations")
    public List<DispensationResponse> list(@PathVariable UUID prescriptionId) {
        return service.listByPrescription(prescriptionId);
    }
}


### File: dispensation-service/src/main/java/tassproject/dispensationservice/DispensationResponse.java
----------------------------------------
package tassproject.dispensationservice;

import tassproject.dispensationservice.Dispensation;
import java.time.OffsetDateTime;
import java.util.UUID;

public record DispensationResponse(UUID id, UUID prescriptionId, OffsetDateTime dispensedAt, UUID dispensedBy, Dispensation.Status status) {
    public static DispensationResponse from(Dispensation d) {
        return new DispensationResponse(d.getId(), d.getPrescriptionId(), d.getDispensedAt(), d.getDispensedBy(), d.getStatus());
    }
}

### File: dispensation-service/src/main/java/tassproject/dispensationservice/DispensationServiceApplication.java
----------------------------------------
package tassproject.dispensationservice;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.domain.EntityScan;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;

@SpringBootApplication(
        // Se hai anche componenti (ad es. @Service, @Component) in prescription-service
        scanBasePackages = {
                "tassproject.dispensationservice",
                "tassproject.prescriptionservice"
        }
)
@EntityScan(basePackages = {
        "tassproject.dispensationservice",     // le tue entit√† locali
        "tassproject.prescriptionservice"      // quelle di Prescription
})
@EnableJpaRepositories(basePackages = {
        "tassproject.dispensationservice.repository",   // i repo di Dispensation
        "tassproject.prescriptionservice.repository"   // i repo di Prescription
})
public class DispensationServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(DispensationServiceApplication.class, args);
    }

}


### File: dispensation-service/src/main/java/tassproject/dispensationservice/RabbitConfig.java
----------------------------------------
package tassproject.dispensationservice;

import org.springframework.amqp.core.Binding;
import org.springframework.amqp.core.BindingBuilder;
import org.springframework.amqp.core.Exchange;
import org.springframework.amqp.core.ExchangeBuilder;
import org.springframework.amqp.core.Queue;
import org.springframework.amqp.core.QueueBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class RabbitConfig {

    @Bean
    public Exchange dispensationExchange() {
        return ExchangeBuilder
                .topicExchange("dispensation.events")
                .durable(true)
                .build();
    }

    @Bean
    public Queue dispensationQueue() {
        return QueueBuilder
                .durable("dispensation.queue")
                .build();
    }

    @Bean
    public Binding bindDispensationEvents(Queue dispensationQueue, Exchange dispensationExchange) {
        return BindingBuilder
                .bind(dispensationQueue)
                .to(dispensationExchange)
                .with("#")
                .noargs();
    }
}


### File: dispensation-service/src/main/resources/application.properties
----------------------------------------
spring.application.name=dispensation-service
server.port=${SERVER_PORT:8080}

spring.datasource.url=${SPRING_DATASOURCE_URL:jdbc:postgresql://localhost:5432/mydatabase}
spring.datasource.username=${SPRING_DATASOURCE_USERNAME:myuser}
spring.datasource.password=${SPRING_DATASOURCE_PASSWORD:secret}
spring.datasource.driver-class-name=org.postgresql.Driver

spring.jpa.hibernate.ddl-auto=${SPRING_JPA_HIBERNATE_DDL_AUTO:update}
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.properties.hibernate.default_schema=dispensation_service 

management.endpoints.web.exposure.include=health,info

# HikariCP (opzionale)
spring.datasource.hikari.maximum-pool-size=10
spring.datasource.hikari.minimum-idle=2
spring.datasource.hikari.idle-timeout=300000
spring.datasource.hikari.max-lifetime=600000


### File: dispensation-service/src/test/java/tassproject/dispensationservice/DispensationRepositoryIT.java
----------------------------------------
package tassproject.dispensationservice;

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;
import org.springframework.test.context.DynamicPropertyRegistry;
import org.springframework.test.context.DynamicPropertySource;
import org.testcontainers.containers.PostgreSQLContainer;
import org.testcontainers.junit.jupiter.Container;
import org.testcontainers.junit.jupiter.Testcontainers;
import tassproject.dispensationservice.repository.DispensationRepository;

import java.time.OffsetDateTime;
import java.util.UUID;

@Testcontainers
@DataJpaTest
class DispensationRepositoryIT {

    @Container
    static PostgreSQLContainer<?> postgres =
            new PostgreSQLContainer<>("postgres:16-alpine")
                    .withDatabaseName("db")
                    .withUsername("user")
                    .withPassword("pwd");

    @DynamicPropertySource
    static void overrideProps(DynamicPropertyRegistry registry) {
        registry.add("spring.datasource.url",      postgres::getJdbcUrl);
        registry.add("spring.datasource.username", postgres::getUsername);
        registry.add("spring.datasource.password", postgres::getPassword);
    }

    @Autowired
    private DispensationRepository repo;

    @Test
    void saveAndQuery() {
        var disp = new Dispensation(
                UUID.randomUUID(),
                UUID.randomUUID(),
                OffsetDateTime.now(),
                UUID.randomUUID(),
                Dispensation.Status.DONE
        );
        repo.save(disp);

        Assertions.assertEquals(1, repo.findAll().size());
        Assertions.assertTrue(repo.existsById(disp.getId()));
    }
}


### File: dispensation-service/src/test/java/tassproject/dispensationservice/DispensationServiceApplicationTests.java
----------------------------------------
package tassproject.dispensationservice;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class DispensationServiceApplicationTests {

    @Test
    void contextLoads() {
    }
}


### File: inventory-service/pom.xml
----------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
                             https://maven.apache.org/xsd/maven-4.0.0.xsd">

    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>tassproject.backend</groupId>
        <artifactId>backend</artifactId>
        <version>0.0.1-SNAPSHOT</version>
        <relativePath>../pom.xml</relativePath>
    </parent>

    <artifactId>inventory-service</artifactId>
    <packaging>jar</packaging>
    <name>inventory-service</name>

    <properties>
        <java.version>17</java.version>
        <testcontainers.version>1.18.3</testcontainers.version>
    </properties>

    <dependencies>
        <!-- Core -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>tassproject.backend</groupId>
            <artifactId>common</artifactId>
            <version>${project.version}</version>
        </dependency>

        <!-- Flyway (üÜï per gestire la rimozione del vecchio FK) -->
        <dependency>
            <groupId>org.flywaydb</groupId>
            <artifactId>flyway-core</artifactId>
        </dependency>

        <!-- Actuator -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>

        <!-- Test -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>testcontainers</artifactId>
            <version>${testcontainers.version}</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>postgresql</artifactId>
            <version>${testcontainers.version}</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>junit-jupiter</artifactId>
            <version>${testcontainers.version}</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>1.18.38</version>
            <scope>provided</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <!-- Lombok annotation processing -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.11.0</version>
                <configuration>
                    <annotationProcessorPaths>
                        <path>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                            <version>1.18.38</version>
                        </path>
                    </annotationProcessorPaths>
                    <release>${java.version}</release>
                </configuration>
            </plugin>

            <!-- Spring Boot -->
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <version>${spring-boot.version}</version>
                <executions>
                    <execution>
                        <goals><goal>repackage</goal></goals>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>

</project>


### File: inventory-service/src/main/java/tassproject/inventoryservice/AvailabilityResponse.java
----------------------------------------
package tassproject.inventoryservice;

import java.util.UUID;

public record AvailabilityResponse(UUID drugId, int quantity) {}

### File: inventory-service/src/main/java/tassproject/inventoryservice/GlobalExceptionHandler.java
----------------------------------------
package tassproject.inventoryservice;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;

/**
 * Trasforma le eccezioni di validazione in risposte HTTP leggibili.
 */
@ControllerAdvice
class GlobalExceptionHandler {

    @ExceptionHandler(IllegalArgumentException.class)
    ResponseEntity<ErrorDTO> handleBadRequest(IllegalArgumentException ex) {
        return ResponseEntity
                .status(HttpStatus.BAD_REQUEST)
                .body(new ErrorDTO(ex.getMessage()));
    }

    record ErrorDTO(String error) {}
}


### File: inventory-service/src/main/java/tassproject/inventoryservice/InventoryApplicationService.java
----------------------------------------
package tassproject.inventoryservice;

import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import tassproject.inventoryservice.repository.InventoryItemRepository;

import java.time.OffsetDateTime;
import java.util.UUID;

@Service
@RequiredArgsConstructor
@Transactional
public class InventoryApplicationService {

    private final InventoryItemRepository repo;

    /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ lettura ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

    @Transactional(readOnly = true)
    public AvailabilityResponse checkAvailability(UUID drugId) {
        int qty = repo.findByDrugId(drugId)
                .map(InventoryItem::getAvailableQuantity)
                .orElse(0);
        return new AvailabilityResponse(drugId, qty);
    }

    /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ scrittura ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

    public void reserve(UUID drugId, int quantity, String reason) {

        // 1) La riga di magazzino DEVE esistere: se manca ‚Üí 400
        var row = repo.findByDrugId(drugId)
                .orElseThrow(() -> new IllegalArgumentException(
                        "Il farmaco %s non √® presente a magazzino".formatted(drugId)));

        // 2) Controllo stock sufficiente
        if (row.getAvailableQuantity() < quantity) {
            throw new IllegalArgumentException("Scorte insufficienti per la prenotazione");
        }

        // 3) Aggiornamento quantit√†
        row.setAvailableQuantity(row.getAvailableQuantity() - quantity);
        row.setLastUpdated(OffsetDateTime.now());
        repo.save(row);

        // (eventuale publish Rabbit / log, se serve)
    }
}


### File: inventory-service/src/main/java/tassproject/inventoryservice/InventoryController.java
----------------------------------------
package tassproject.inventoryservice;

import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.*;

import java.util.UUID;

@RestController
@RequestMapping("/api/v1")
@RequiredArgsConstructor
public class InventoryController {

    private final InventoryApplicationService service;

    @GetMapping("/inventory/{drugId}/availability")
    public AvailabilityResponse availability(@PathVariable UUID drugId) {
        return service.checkAvailability(drugId);
    }

    /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ nuovo endpoint ‚Äúreserve‚Äù ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

    @PostMapping("/inventory/items/{drugId}/reserve")
    @ResponseStatus(HttpStatus.NO_CONTENT)
    public void reserve(@PathVariable UUID drugId,
                        @RequestBody ReserveInventoryRequest body) {
        service.reserve(drugId, body.quantity(), body.reason());
    }
}


### File: inventory-service/src/main/java/tassproject/inventoryservice/InventoryItem.java
----------------------------------------
package tassproject.inventoryservice;

import jakarta.persistence.*;
import java.time.OffsetDateTime;
import java.util.UUID;

@Entity
@Table(name = "inventory_items")
public class InventoryItem {

    @Id
    @Column(columnDefinition = "uuid")
    private UUID id;

    @Column(name = "drug_id", nullable = false, columnDefinition = "uuid")
    private UUID drugId;

    @Column(name = "available_quantity", nullable = false)
    private int availableQuantity;

    @Column(name = "last_updated", nullable = false)
    private OffsetDateTime lastUpdated;

    // **Costruttore vuoto richiesto da JPA**
    public InventoryItem() {}

    // (Opzionale) costruttore full-args
    public InventoryItem(UUID id, UUID drugId, int availableQuantity, OffsetDateTime lastUpdated) {
        this.id = id;
        this.drugId = drugId;
        this.availableQuantity = availableQuantity;
        this.lastUpdated = lastUpdated;
    }

    // --- Getter e Setter ---
    public UUID getId() {
        return id;
    }
    public void setId(UUID id) {
        this.id = id;
    }

    public UUID getDrugId() {
        return drugId;
    }
    public void setDrugId(UUID drugId) {
        this.drugId = drugId;
    }

    public int getAvailableQuantity() {
        return availableQuantity;
    }
    public void setAvailableQuantity(int availableQuantity) {
        this.availableQuantity = availableQuantity;
    }

    public OffsetDateTime getLastUpdated() {
        return lastUpdated;
    }
    public void setLastUpdated(OffsetDateTime lastUpdated) {
        this.lastUpdated = lastUpdated;
    }
}


### File: inventory-service/src/main/java/tassproject/inventoryservice/InventoryItemRepository.java
----------------------------------------
package tassproject.inventoryservice.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import tassproject.inventoryservice.InventoryItem;

import java.util.Optional;
import java.util.UUID;

public interface InventoryItemRepository extends JpaRepository<InventoryItem, UUID> {

    /* Cerca la riga di magazzino per drugId */
    Optional<InventoryItem> findByDrugId(UUID drugId);
}


### File: inventory-service/src/main/java/tassproject/inventoryservice/InventoryServiceApplication.java
----------------------------------------
package tassproject.inventoryservice;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class InventoryServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(InventoryServiceApplication.class, args);
    }

}


### File: inventory-service/src/main/java/tassproject/inventoryservice/ReserveInventoryRequest.java
----------------------------------------
package tassproject.inventoryservice;

import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotBlank;

public record ReserveInventoryRequest(
        @Min(1) int quantity,
        @NotBlank String reason) {}


### File: inventory-service/src/main/resources/application.properties
----------------------------------------
spring.application.name=inventory-service
server.port=${SERVER_PORT:8080}

# ???????????????? DATASOURCE ????????????????
spring.datasource.url=${SPRING_DATASOURCE_URL:jdbc:postgresql://localhost:5432/mydatabase}
spring.datasource.username=${SPRING_DATASOURCE_USERNAME:myuser}
spring.datasource.password=${SPRING_DATASOURCE_PASSWORD:secret}
spring.datasource.driver-class-name=org.postgresql.Driver

# ???????????????? JPA / HIBERNATE ????????????????
spring.jpa.hibernate.ddl-auto=${SPRING_JPA_HIBERNATE_DDL_AUTO:update}
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.properties.hibernate.default_schema=inventory_service

# ???????????????? FLYWAY ????????????????
spring.flyway.schemas=inventory_service
spring.flyway.baseline-on-migrate=true
spring.flyway.baseline-version=0

# ???????????????? ACTUATOR ????????????????
management.endpoints.web.exposure.include=health,info

# ???????????????? HIKARICP ????????????????
spring.datasource.hikari.maximum-pool-size=10
spring.datasource.hikari.minimum-idle=2
spring.datasource.hikari.idle-timeout=300000
spring.datasource.hikari.max-lifetime=600000


### File: inventory-service/src/main/resources/db/migration/V1__drop_inventory_items_drug_fk.sql
----------------------------------------
-- Rimuove il vecchio vincolo che puntava alla tabella inesistente "drugs"
ALTER TABLE IF EXISTS inventory_service.inventory_items
    DROP CONSTRAINT IF EXISTS inventory_items_drug_id_fkey;


### File: inventory-service/src/test/java/tassproject/inventoryservice/InventoryItemRepositoryIT.java
----------------------------------------
package tassproject.inventoryservice;

import org.junit.jupiter.api.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;
import org.springframework.test.context.DynamicPropertyRegistry;
import org.springframework.test.context.DynamicPropertySource;
import org.testcontainers.containers.PostgreSQLContainer;
import org.testcontainers.junit.jupiter.Container;
import org.testcontainers.junit.jupiter.Testcontainers;
import tassproject.inventoryservice.repository.InventoryItemRepository;

import java.time.OffsetDateTime;
import java.util.UUID;

@Testcontainers
@DataJpaTest
class InventoryItemRepositoryIT {

    @Container
    static PostgreSQLContainer<?> postgres =
            new PostgreSQLContainer<>("postgres:16-alpine")
                    .withDatabaseName("db")
                    .withUsername("user")
                    .withPassword("pwd");

    @DynamicPropertySource
    static void props(DynamicPropertyRegistry r) {
        r.add("spring.datasource.url", postgres::getJdbcUrl);
        r.add("spring.datasource.username", postgres::getUsername);
        r.add("spring.datasource.password", postgres::getPassword);
    }

    @Autowired
    InventoryItemRepository repo;

    @Test
    void positiveStockUpdate() {
        var row = new InventoryItem();
        row.setId(UUID.randomUUID());
        row.setDrugId(UUID.randomUUID());
        row.setAvailableQuantity(10);
        row.setLastUpdated(OffsetDateTime.now());

        repo.save(row);

        var loaded = repo.findById(row.getId()).orElseThrow();
        loaded.setAvailableQuantity(loaded.getAvailableQuantity() + 5);
        repo.save(loaded);

        Assertions.assertEquals(15, repo.findById(row.getId()).orElseThrow().getAvailableQuantity());
    }
}


### File: inventory-service/src/test/java/tassproject/inventoryservice/InventoryServiceApplicationTests.java
----------------------------------------
package tassproject.inventoryservice;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class InventoryServiceApplicationTests {

    @Test
    void contextLoads() {
    }

}


### File: notification-service/pom.xml
----------------------------------------
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
                             https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <!-- 1) Ereditamo dal parent aggregator -->
    <parent>
        <groupId>tassproject.backend</groupId>
        <artifactId>backend</artifactId>
        <version>0.0.1-SNAPSHOT</version>
        <relativePath>../pom.xml</relativePath>
    </parent>

    <!-- 2) Coordinate di questo modulo -->
    <groupId>tassproject.backend</groupId>
    <artifactId>notification-service</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <packaging>jar</packaging>
    <name>notification-service</name>

    <properties>
        <java.version>17</java.version>
    </properties>

    <dependencies>
        <!-- Core Spring Boot + REST/RabbitMQ -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-amqp</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>

        <!-- Lombok -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>1.18.38</version>
            <scope>provided</scope>
        </dependency>

        <!-- Common condiviso ‚Üí usa lo stesso groupId del parent -->
        <dependency>
            <groupId>tassproject.backend</groupId>
            <artifactId>common</artifactId>
            <version>${project.version}</version>
        </dependency>

        <!-- Test -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <!-- Actuator per health-check -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>

    </dependencies>

    <build>
        <plugins>
            <!-- Lombok annotation processing -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.11.0</version>
                <configuration>
                    <annotationProcessorPaths>
                        <path>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                            <version>1.18.38</version>
                        </path>
                    </annotationProcessorPaths>
                    <release>${java.version}</release>
                </configuration>
            </plugin>
            <!-- Spring Boot -->
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>


### File: notification-service/src/main/java/tassproject/notificationservice/NotificationController.java
----------------------------------------
package tassproject.notificationservice;

import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.*;
import tassproject.notificationservice.SendNotificationRequest;

@RestController
@RequestMapping("/api/v1")
@RequiredArgsConstructor
public class NotificationController {
    private final RabbitTemplate rabbitTemplate;

    @PostMapping("/notifications")
    @ResponseStatus(HttpStatus.ACCEPTED)
    public void notify(@Valid @RequestBody SendNotificationRequest request) {
        rabbitTemplate.convertAndSend("notification.events", request.type().name(), request);
    }
}


### File: notification-service/src/main/java/tassproject/notificationservice/NotificationServiceApplication.java
----------------------------------------
package tassproject.notificationservice;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class NotificationServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(NotificationServiceApplication.class, args);
    }

}


### File: notification-service/src/main/java/tassproject/notificationservice/RabbitConfig.java
----------------------------------------
package tassproject.notificationservice;

import org.springframework.amqp.core.Binding;
import org.springframework.amqp.core.BindingBuilder;
import org.springframework.amqp.core.Exchange;
import org.springframework.amqp.core.ExchangeBuilder;
import org.springframework.amqp.core.Queue;
import org.springframework.amqp.core.QueueBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class RabbitConfig {

    @Bean
    public Exchange notificationExchange() {
        return ExchangeBuilder
                .directExchange("notification.events")
                .durable(true)
                .build();
    }

    @Bean
    public Queue notificationQueue() {
        return QueueBuilder
                .durable("notification.queue")
                .build();
    }

    @Bean
    public Binding bindNotification(Queue notificationQueue, Exchange notificationExchange) {
        return BindingBuilder
                .bind(notificationQueue)
                .to(notificationExchange)
                .with("INFO")
                .noargs();
    }
}


### File: notification-service/src/main/java/tassproject/notificationservice/SendNotificationRequest.java
----------------------------------------
package tassproject.notificationservice;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import java.io.Serializable;          // üëà nuovo import
import java.util.UUID;

public record SendNotificationRequest(
        @NotNull  UUID  recipientId,
        @NotBlank String message,
        @NotNull  Type   type)
        implements Serializable {     // üëà implementa Serializable

    public enum Type { INFO, WARNING, ERROR }
}


### File: notification-service/src/main/resources/application.properties
----------------------------------------
spring.application.name=notification-service
server.port=${SERVER_PORT:8080}

spring.datasource.url=${SPRING_DATASOURCE_URL:jdbc:postgresql://localhost:5432/mydatabase}
spring.datasource.username=${SPRING_DATASOURCE_USERNAME:myuser}
spring.datasource.password=${SPRING_DATASOURCE_PASSWORD:secret}
spring.datasource.driver-class-name=org.postgresql.Driver

spring.jpa.hibernate.ddl-auto=${SPRING_JPA_HIBERNATE_DDL_AUTO:update}
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.properties.hibernate.default_schema=notification_service

management.endpoints.web.exposure.include=health,info

# HikariCP (opzionale)
spring.datasource.hikari.maximum-pool-size=10
spring.datasource.hikari.minimum-idle=2
spring.datasource.hikari.idle-timeout=300000
spring.datasource.hikari.max-lifetime=600000


### File: notification-service/src/test/java/tassproject/notificationservice/NotificationServiceApplicationTests.java
----------------------------------------
package tassproject.notificationservice;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class NotificationServiceApplicationTests {

    @Test
    void contextLoads() {
    }

}


### File: pom.xml
----------------------------------------
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="
           http://maven.apache.org/POM/4.0.0
           https://maven.apache.org/xsd/maven-4.0.0.xsd">

    <modelVersion>4.0.0</modelVersion>

    <!-- 1) Estendiamo Spring Boot Starter Parent per pluginManagement -->
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.1.4</version>
        <relativePath/> <!-- non cercare pom locale -->
    </parent>

    <!-- 2) Coordinate del modulo aggregatore -->
    <groupId>tassproject.backend</groupId>
    <artifactId>backend</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <packaging>pom</packaging>

    <name>TAAS Backend Aggregator</name>
    <description>Aggregatore dei microservizi backend per TAAS</description>

    <!-- 3) Propriet√† condivise -->
    <properties>
        <!-- Java & Spring versions -->
        <java.version>17</java.version>
        <spring-boot.version>3.1.4</spring-boot.version>
        <spring-cloud.version>2023.0.3</spring-cloud.version>

        <!-- Driver & utility libs -->
        <postgresql.version>42.6.0</postgresql.version>
        <lombok.version>1.18.38</lombok.version>
        <testcontainers.version>1.18.3</testcontainers.version>
    </properties>

    <!-- 4) Import dei BOM di Spring Boot e Spring Cloud + gestione versioni comuni -->
    <dependencyManagement>
        <dependencies>
            <!-- Spring Boot dependencies BOM -->
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-dependencies</artifactId>
                <version>${spring-boot.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
            <!-- Spring Cloud dependencies BOM -->
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>${spring-cloud.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>

            <!-- Versione gestita del driver PostgreSQL -->
            <dependency>
                <groupId>org.postgresql</groupId>
                <artifactId>postgresql</artifactId>
                <version>${postgresql.version}</version>
                <scope>runtime</scope>
            </dependency>

            <!-- Lombok (annotation processing) -->
            <dependency>
                <groupId>org.projectlombok</groupId>
                <artifactId>lombok</artifactId>
                <version>${lombok.version}</version>
            </dependency>

            <!-- Testcontainers -->
            <dependency>
                <groupId>org.testcontainers</groupId>
                <artifactId>testcontainers</artifactId>
                <version>${testcontainers.version}</version>
                <scope>test</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>

    <!-- 4b) Dipendenze comuni ereditate dai moduli -->
    <dependencies>
        <!-- Driver JDBC PostgreSQL disponibile a runtime -->
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>
    </dependencies>

    <!-- 5) Configurazione centralizzata dei plugin Maven -->
    <build>
        <pluginManagement>
            <plugins>
                <!-- Compiler plugin per Java 17 + lombok -->
                <plugin>
                    <groupId>org.apache.maven.plugins</groupId>
                    <artifactId>maven-compiler-plugin</artifactId>
                    <version>3.11.0</version>
                    <configuration>
                        <source>${java.version}</source>
                        <target>${java.version}</target>
                        <annotationProcessorPaths>
                            <path>
                                <groupId>org.projectlombok</groupId>
                                <artifactId>lombok</artifactId>
                                <version>${lombok.version}</version>
                            </path>
                        </annotationProcessorPaths>
                    </configuration>
                </plugin>

                <!-- Spring Boot Maven Plugin -->
                <plugin>
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-maven-plugin</artifactId>
                    <version>${spring-boot.version}</version>
                </plugin>
            </plugins>
        </pluginManagement>
    </build>

    <!-- 6) Moduli figli -->
    <modules>
        <module>common</module>
        <module>api-gateway</module>
        <module>prescription-service</module>
        <module>dispensation-service</module>
        <module>inventory-service</module>
        <module>notification-service</module>
        <module>auth-service</module>
    </modules>


</project>


### File: prescription-service/pom.xml
----------------------------------------
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
                             https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>tassproject.backend</groupId>
        <artifactId>backend</artifactId>
        <version>0.0.1-SNAPSHOT</version>
        <relativePath>../pom.xml</relativePath>
    </parent>

    <artifactId>prescription-service</artifactId>
    <packaging>jar</packaging>
    <name>prescription-service</name>

    <!-- 1Ô∏è‚É£ Propriet√† generali -->
    <properties>
        <!-- forziamo UTF-8 su sorgenti, report e resources -->
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
        <java.version>17</java.version>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-amqp</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        <dependency>
            <groupId>tassproject.backend</groupId>
            <artifactId>common</artifactId>
            <version>${project.version}</version>
        </dependency>
        <dependency>
            <groupId>org.flywaydb</groupId>
            <artifactId>flyway-core</artifactId>
        </dependency>
        <!-- Test e Testcontainers -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>testcontainers</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>junit-jupiter</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>postgresql</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
        </dependency>
    </dependencies>

    <build>
        <!-- Disabilitiamo il resource filtering -->
        <resources>
            <resource>
                <directory>src/main/resources</directory>
                <filtering>false</filtering>
            </resource>
        </resources>

        <plugins>
            <!-- Impostiamo l‚Äôencoding su UTF-8 anche nel Resources Plugin -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-resources-plugin</artifactId>
                <version>3.3.1</version>
                <configuration>
                    <encoding>UTF-8</encoding>
                </configuration>
            </plugin>

            <!-- Compiler Plugin (per sicurezza, Java 17) -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.11.0</version>
                <configuration>
                    <source>${java.version}</source>
                    <target>${java.version}</target>
                    <encoding>${project.build.sourceEncoding}</encoding>
                </configuration>
            </plugin>

            <!-- Spring Boot Maven Plugin -->
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>


### File: prescription-service/src/main/java/tassproject/prescriptionservice/CreatePrescriptionRequest.java
----------------------------------------
package tassproject.prescriptionservice;

import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import java.util.List;
import java.util.UUID;

public record CreatePrescriptionRequest(
        @NotNull UUID doctorId,
        @NotNull UUID patientId,
        String therapyDuration,
        boolean exemption,
        @NotNull @Size(min = 1) List<PrescriptionItemDto> items
) {}


### File: prescription-service/src/main/java/tassproject/prescriptionservice/GlobalExceptionHandler.java
----------------------------------------
package tassproject.prescriptionservice;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;

@ControllerAdvice
public class GlobalExceptionHandler {
    @ExceptionHandler(Exception.class)
    public ResponseEntity<?> handleException(Exception ex) {
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(new ErrorDTO("Server error", ex.getMessage()));
    }

    record ErrorDTO(String error, String details) {}
}


### File: prescription-service/src/main/java/tassproject/prescriptionservice/Prescription.java
----------------------------------------
package tassproject.prescriptionservice;

import jakarta.persistence.*;
import java.time.OffsetDateTime;
import java.util.*;

@Entity
@Table(name = "prescriptions")
public class Prescription {

    @Id
    @Column(columnDefinition = "uuid")
    private UUID id;

    @Column(name = "doctor_id", nullable = false, columnDefinition = "uuid")
    private UUID doctorId;

    @Column(name = "patient_id", nullable = false, columnDefinition = "uuid")
    private UUID patientId;

    @Column(name = "issued_at", nullable = false)
    private OffsetDateTime issuedAt;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private Status status;

    @Column(name = "exemption", nullable = false)
    private boolean exemption; // true = esente ticket, false = non esente

    @Column(name = "therapy_duration")
    private String therapyDuration; // Es: "7 giorni" (mappato direttamente per semplicit√†)

    @OneToMany(
            mappedBy = "prescription",
            cascade = CascadeType.ALL,
            orphanRemoval = true,
            fetch = FetchType.LAZY
    )
    private List<PrescriptionItem> items = new ArrayList<>();

    // --- Enum Stato Ricetta ---
    public enum Status {
        OPEN,
        DISPENSED,
        COMPLETED,
        CANCELLED
    }

    // --- Costruttori ---
    protected Prescription() {} // richiesto da JPA

    public Prescription(UUID id, UUID doctorId, UUID patientId, OffsetDateTime issuedAt, boolean exemption, String therapyDuration, List<PrescriptionItem> items) {
        this.id = id;
        this.doctorId = doctorId;
        this.patientId = patientId;
        this.issuedAt = issuedAt;
        this.status = Status.OPEN;
        this.exemption = exemption;
        this.therapyDuration = therapyDuration;
        setItems(items); // associa gli items a questa prescription
    }

    // Factory per nuove prescrizioni
    public static Prescription create(UUID doctorId, UUID patientId, boolean exemption, String therapyDuration, List<PrescriptionItem> items) {
        return new Prescription(UUID.randomUUID(), doctorId, patientId, OffsetDateTime.now(), exemption, therapyDuration, items);
    }

    // --- Metodi dominio ---
    public boolean isOpen() {
        return status == Status.OPEN;
    }

    public boolean isCompleted() {
        return status == Status.COMPLETED;
    }

    public boolean isDispensed() {
        return status == Status.DISPENSED;
    }

    public boolean isCancelled() {
        return status == Status.CANCELLED;
    }

    public void markDispensed() {
        if (!isOpen()) throw new IllegalStateException("Prescription must be OPEN to be dispensed.");
        this.status = Status.DISPENSED;
    }

    public void markCompleted() {
        if (status != Status.DISPENSED) throw new IllegalStateException("Prescription must be DISPENSED to complete.");
        this.status = Status.COMPLETED;
    }

    public void cancel() {
        if (isCompleted()) throw new IllegalStateException("Cannot cancel a completed prescription.");
        this.status = Status.CANCELLED;
    }

    // --- Getter e Setter ---
    public UUID getId() { return id; }
    public UUID getDoctorId() { return doctorId; }
    public UUID getPatientId() { return patientId; }
    public OffsetDateTime getIssuedAt() { return issuedAt; }
    public Status getStatus() { return status; }
    public boolean isExemption() { return exemption; }
    public String getTherapyDuration() { return therapyDuration; }
    public List<PrescriptionItem> getItems() { return items; }

    public void setItems(List<PrescriptionItem> items) {
        this.items.clear();
        if (items != null) {
            for (PrescriptionItem item : items) {
                item.setPrescription(this); // imposta il back-reference
                this.items.add(item);
            }
        }
    }

    // Opzionale: aggiungi utility per frontend
    public String getEsenzioneAsString() {
        return exemption ? "Si" : "No";
    }
}


### File: prescription-service/src/main/java/tassproject/prescriptionservice/PrescriptionApplicationService.java
----------------------------------------
package tassproject.prescriptionservice;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import tassproject.prescriptionservice.repository.PrescriptionRepository;

import java.util.List;
import java.util.UUID;

@Service
@Transactional
public class PrescriptionApplicationService {
    private final PrescriptionRepository repo;
    private final RabbitTemplate rabbitTemplate;

    public PrescriptionApplicationService(PrescriptionRepository repo,
                                          RabbitTemplate rabbitTemplate) {
        this.repo = repo;
        this.rabbitTemplate = rabbitTemplate;
    }

    public PrescriptionResponse create(CreatePrescriptionRequest req) {
        List<PrescriptionItem> items = req.items().stream()
                .map(dto -> new PrescriptionItem(
                        dto.drugId(),
                        dto.activeIngredientId(),
                        dto.activeIngredient(),
                        dto.dosage(),
                        dto.quantity()))
                .toList();

        Prescription entity = Prescription.create(
                req.doctorId(),
                req.patientId(),
                req.exemption(),
                req.therapyDuration(),
                items);

        entity = repo.save(entity);
        rabbitTemplate.convertAndSend(
                "prescription.events",
                "PrescriptionCreated",
                entity.getId());

        return PrescriptionResponse.from(entity);
    }

    @Transactional(readOnly = true)
    public PrescriptionResponse findById(UUID id) {
        return repo.findById(id)
                .map(PrescriptionResponse::from)
                .orElseThrow();
    }

    @Transactional(readOnly = true)
    public List<PrescriptionResponse> findActiveByPatientId(UUID patientId) {
        return repo.findAll().stream()
                .filter(p -> p.getPatientId().equals(patientId))
                .filter(p -> p.getStatus() == Prescription.Status.OPEN
                        || p.getStatus() == Prescription.Status.DISPENSED)
                .map(PrescriptionResponse::from)
                .toList();
    }

    public PrescriptionResponse updateStatus(UUID id, Prescription.Status newStatus) {
        Prescription entity = repo.findById(id).orElseThrow();
        switch (newStatus) {
            case DISPENSED -> entity.markDispensed();
            case COMPLETED -> entity.markCompleted();
            case CANCELLED -> entity.cancel();
            default -> throw new IllegalStateException("Unsupported status transition");
        }
        repo.save(entity);
        rabbitTemplate.convertAndSend(
                "prescription.events",
                "PrescriptionStatusChanged",
                entity.getId());
        return PrescriptionResponse.from(entity);
    }
}


### File: prescription-service/src/main/java/tassproject/prescriptionservice/PrescriptionController.java
----------------------------------------
package tassproject.prescriptionservice;

import jakarta.validation.Valid;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.*;
import tassproject.prescriptionservice.PrescriptionApplicationService;

import java.util.List;
import java.util.UUID;

@RestController
@RequestMapping("/api/v1")
public class PrescriptionController {

    private final PrescriptionApplicationService service;

    // Costruttore esplicito per l‚Äôinjection del service
    public PrescriptionController(PrescriptionApplicationService service) {
        this.service = service;
    }

    @PostMapping("/prescriptions")
    @ResponseStatus(HttpStatus.CREATED)
    public PrescriptionResponse create(@Valid @RequestBody CreatePrescriptionRequest request) {
        return service.create(request);
    }

    @GetMapping("/prescriptions/{id}")
    public PrescriptionResponse findById(@PathVariable UUID id) {
        return service.findById(id);
    }

    @GetMapping("/patients/{patientId}/prescriptions/active")
    public List<PrescriptionResponse> findActive(@PathVariable UUID patientId) {
        return service.findActiveByPatientId(patientId);
    }

    @PutMapping("/prescriptions/{id}/status")
    public PrescriptionResponse updateStatus(
            @PathVariable UUID id,
            @Valid @RequestBody UpdatePrescriptionStatusRequest body) {
        return service.updateStatus(id, body.newStatus());
    }
}


### File: prescription-service/src/main/java/tassproject/prescriptionservice/PrescriptionItem.java
----------------------------------------
package tassproject.prescriptionservice;

import jakarta.persistence.*;
import java.util.UUID;

@Entity
@Table(name = "prescription_items")
public class PrescriptionItem {

    @Id
    @Column(columnDefinition = "uuid")
    private UUID id;

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "prescription_id", nullable = false, columnDefinition = "uuid")
    private Prescription prescription;

    @Column(name = "drug_id", nullable = false, columnDefinition = "uuid")
    private UUID drugId;

    @Column(name = "active_ingredient_id", nullable = false, columnDefinition = "uuid")
    private UUID activeIngredientId;

    @Column(name = "active_ingredient", nullable = false)
    private String activeIngredient;

    @Column(nullable = false)
    private String dosage;

    @Column(nullable = false)
    private int quantity;

    protected PrescriptionItem() {
        // per JPA
    }

    public PrescriptionItem(UUID drugId,
                            UUID activeIngredientId,
                            String activeIngredient,
                            String dosage,
                            int quantity) {
        this.id = UUID.randomUUID();
        this.drugId = drugId;
        this.activeIngredientId = activeIngredientId;
        this.activeIngredient = activeIngredient;
        this.dosage = dosage;
        this.quantity = quantity;
    }

    public UUID getId() {
        return id;
    }

    public Prescription getPrescription() {
        return prescription;
    }

    public void setPrescription(Prescription prescription) {
        this.prescription = prescription;
    }

    public UUID getDrugId() {
        return drugId;
    }

    public void setDrugId(UUID drugId) {
        this.drugId = drugId;
    }

    public UUID getActiveIngredientId() {
        return activeIngredientId;
    }

    public void setActiveIngredientId(UUID activeIngredientId) {
        this.activeIngredientId = activeIngredientId;
    }

    public String getActiveIngredient() {
        return activeIngredient;
    }

    public void setActiveIngredient(String activeIngredient) {
        this.activeIngredient = activeIngredient;
    }

    public String getDosage() {
        return dosage;
    }

    public void setDosage(String dosage) {
        this.dosage = dosage;
    }

    public int getQuantity() {
        return quantity;
    }

    public void setQuantity(int quantity) {
        this.quantity = quantity;
    }

    public String getDescrizionePrincipioAttivo() {
        return activeIngredient + " " + dosage;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof PrescriptionItem)) return false;
        PrescriptionItem that = (PrescriptionItem) o;
        return id.equals(that.id);
    }

    @Override
    public int hashCode() {
        return id.hashCode();
    }
}


### File: prescription-service/src/main/java/tassproject/prescriptionservice/PrescriptionItemDto.java
----------------------------------------
package tassproject.prescriptionservice;

import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import java.util.UUID;

public record PrescriptionItemDto(
        @NotNull UUID drugId,
        @NotNull UUID activeIngredientId,
        @NotBlank String activeIngredient,
        @NotBlank String dosage,
        @Min(1) int quantity
) {}


### File: prescription-service/src/main/java/tassproject/prescriptionservice/PrescriptionItemRepository.java
----------------------------------------
// PrescriptionItemRepository.java
package tassproject.prescriptionservice.repository;

import java.util.UUID;
import org.springframework.data.jpa.repository.JpaRepository;
import tassproject.prescriptionservice.PrescriptionItem;

public interface PrescriptionItemRepository extends JpaRepository<PrescriptionItem, UUID> { }


### File: prescription-service/src/main/java/tassproject/prescriptionservice/PrescriptionRepository.java
----------------------------------------
// PrescriptionRepository.java
package tassproject.prescriptionservice.repository;

import java.util.UUID;
import org.springframework.data.jpa.repository.JpaRepository;
import tassproject.prescriptionservice.Prescription;

public interface PrescriptionRepository extends JpaRepository<Prescription, UUID> { }


### File: prescription-service/src/main/java/tassproject/prescriptionservice/PrescriptionResponse.java
----------------------------------------
package tassproject.prescriptionservice;

import java.time.OffsetDateTime;
import java.util.List;
import java.util.UUID;

public record PrescriptionResponse(
        UUID id,
        UUID doctorId,
        UUID patientId,
        OffsetDateTime issuedAt,
        Prescription.Status status,
        boolean exemption,
        String therapyDuration,
        List<PrescriptionItemDto> items
) {
    public static PrescriptionResponse from(Prescription p) {
        return new PrescriptionResponse(
                p.getId(),
                p.getDoctorId(),
                p.getPatientId(),
                p.getIssuedAt(),
                p.getStatus(),
                p.isExemption(),
                p.getTherapyDuration(),
                p.getItems().stream()
                        .map(it -> new PrescriptionItemDto(
                                it.getDrugId(),
                                it.getActiveIngredientId(),
                                it.getActiveIngredient(),
                                it.getDosage(),
                                it.getQuantity()))
                        .toList()
        );
    }
}


### File: prescription-service/src/main/java/tassproject/prescriptionservice/PrescriptionServiceApplication.java
----------------------------------------
package tassproject.prescriptionservice;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class PrescriptionServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(PrescriptionServiceApplication.class, args);
    }

}


### File: prescription-service/src/main/java/tassproject/prescriptionservice/RabbitConfig.java
----------------------------------------
package tassproject.prescriptionservice;

import org.springframework.amqp.core.Binding;
import org.springframework.amqp.core.BindingBuilder;
import org.springframework.amqp.core.Exchange;
import org.springframework.amqp.core.ExchangeBuilder;
import org.springframework.amqp.core.Queue;
import org.springframework.amqp.core.QueueBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class RabbitConfig {

    @Bean
    public Exchange prescriptionExchange() {
        return ExchangeBuilder
                .topicExchange("prescription.events")
                .durable(true)
                .build();
    }

    @Bean
    public Queue prescriptionQueue() {
        return QueueBuilder
                .durable("prescription.queue")
                .build();
    }

    @Bean
    public Binding bindPrescriptionEvents(Queue prescriptionQueue, Exchange prescriptionExchange) {
        return BindingBuilder
                .bind(prescriptionQueue)
                .to(prescriptionExchange)
                .with("#")
                .noargs();
    }
}


### File: prescription-service/src/main/java/tassproject/prescriptionservice/UpdatePrescriptionStatusRequest.java
----------------------------------------
package tassproject.prescriptionservice;

import jakarta.validation.constraints.NotNull;
import tassproject.prescriptionservice.Prescription;

public record UpdatePrescriptionStatusRequest(@NotNull Prescription.Status newStatus) {}

### File: prescription-service/src/main/resources/application.properties
----------------------------------------
<<ERROR reading file: 'utf-8' codec can't decode byte 0xe0 in position 393: invalid continuation byte>>


### File: prescription-service/src/main/resources/db/migration/V1__drop_foreign_keys.sql
----------------------------------------
-- Rimuove (se esiste) il vincolo che blocca l'inserimento
ALTER TABLE IF EXISTS prescription_service.prescriptions
    DROP CONSTRAINT IF EXISTS prescriptions_doctor_id_fkey;


### File: prescription-service/src/test/java/tassproject/prescriptionservice/PrescriptionRepositoryIT.java
----------------------------------------
package tassproject.prescriptionservice;

import org.junit.jupiter.api.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;
import org.springframework.test.context.DynamicPropertyRegistry;
import org.springframework.test.context.DynamicPropertySource;
import org.testcontainers.containers.PostgreSQLContainer;
import org.testcontainers.junit.jupiter.Container;
import org.testcontainers.junit.jupiter.Testcontainers;
import tassproject.prescriptionservice.repository.PrescriptionRepository;
import tassproject.prescriptionservice.repository.PrescriptionItemRepository;

import java.time.OffsetDateTime;
import java.util.List;
import java.util.UUID;

@Testcontainers
@DataJpaTest
class PrescriptionRepositoryIT {

    @Container
    static PostgreSQLContainer<?> postgres =
            new PostgreSQLContainer<>("postgres:16-alpine")
                    .withDatabaseName("db")
                    .withUsername("user")
                    .withPassword("pwd");

    @DynamicPropertySource
    static void overrideProps(DynamicPropertyRegistry r) {
        r.add("spring.datasource.url", postgres::getJdbcUrl);
        r.add("spring.datasource.username", postgres::getUsername);
        r.add("spring.datasource.password", postgres::getPassword);
    }

    @Autowired
    PrescriptionRepository prescriptions;

    @Autowired
    PrescriptionItemRepository items;

    @Test
    void crudEndToEnd() {
        // --- create ---
        UUID drugId = UUID.randomUUID();
        UUID activeIngredientId = UUID.randomUUID();
        String activeIngredient = "Paracetamolo";
        String dosage = "500mg";
        int quantity = 2;
        var item = new PrescriptionItem(
                drugId,
                activeIngredientId,
                activeIngredient,
                dosage,
                quantity
        );
        var presc = Prescription.create(
                UUID.randomUUID(), UUID.randomUUID(), false,
                "7 giorni", List.of(item));
        presc = prescriptions.save(presc);

        Assertions.assertNotNull(presc.getId());
        Assertions.assertEquals(1, presc.getItems().size());

        // --- read ---
        var found = prescriptions.findById(presc.getId()).orElseThrow();
        Assertions.assertEquals(presc.getDoctorId(), found.getDoctorId());

        // --- update ---
        found.markDispensed();
        prescriptions.save(found);
        Assertions.assertTrue(prescriptions.findById(found.getId()).orElseThrow().isDispensed());

        // --- delete (cascata su items) ---
        prescriptions.delete(found);
        Assertions.assertTrue(prescriptions.findAll().isEmpty());
        Assertions.assertTrue(items.findAll().isEmpty());
    }
}


### File: prescription-service/src/test/java/tassproject/prescriptionservice/PrescriptionServiceApplicationTests.java
----------------------------------------
package tassproject.prescriptionservice;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class PrescriptionServiceApplicationTests {

    @Test
    void contextLoads() {
    }

}


### File: src/main/java/tassproject/backend/BackendApplication.java
----------------------------------------
package tassproject.backend;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class BackendApplication {

    public static void main(String[] args) {
        SpringApplication.run(BackendApplication.class, args);
    }

}


### File: src/main/resources/application.properties
----------------------------------------
spring.application.name=dispensation-service   # cambia il nome
server.port=${SERVER_PORT:8080}               # fallback 8080, sovrascrivi in compose

spring.datasource.url=${SPRING_DATASOURCE_URL:jdbc:postgresql://localhost:5432/mydatabase}
spring.datasource.username=${SPRING_DATASOURCE_USERNAME:myuser}
spring.datasource.password=${SPRING_DATASOURCE_PASSWORD:secret}
spring.datasource.driver-class-name=org.postgresql.Driver

spring.jpa.hibernate.ddl-auto=${SPRING_JPA_HIBERNATE_DDL_AUTO:update}
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect

# esponi via HTTP gli endpoint health e info
management.endpoints.web.exposure.include=health,info


# HikariCP (opzionale)
spring.datasource.hikari.maximum-pool-size=10
spring.datasource.hikari.minimum-idle=2
spring.datasource.hikari.idle-timeout=300000
spring.datasource.hikari.max-lifetime=600000


### File: src/test/java/tassproject/backend/BackendApplicationTests.java
----------------------------------------
package tassproject.backend;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class BackendApplicationTests {

    @Test
    void contextLoads() {
    }

}


